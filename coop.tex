\documentclass{article}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx} % Required for inserting images
\usepackage{color}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
    pdfpagemode=UseNone,
}
% \usepackage{multirow}
\usepackage{macros}
% \usepackage{forest}
% \forestset{qtree edges/.style={for tree={parent anchor=south, child anchor=north}}}

\usepackage{epigraph}
\setlength{\epigraphwidth}{\textwidth}
\setlength{\epigraphrule}{0pt}

\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{Concepts (Principles) of Object-Oriented Programming \\ Study Guide}
\author{Karl Marx}
\date{\today}

\begin{document}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\newtheorem{example}{Example}[section]

\maketitle

\epigraph{\itshape Object-oriented programming is an exceptionally bad idea which could only have originated in California.}{Edsger Dijkstra}

\tableofcontents

\section{Introduction}

This study guide takes its information from the \href{https://www.pm.inf.ethz.ch/education/courses/COOP.html}{Concepts of Object-Oriented Programming course website}.

Objects have:
\begin{itemize}
    \item State
    \item Location in memory
    \item Behavior
\end{itemize}

Core concepts:
\begin{itemize}
    \item Object model
    \item Interfaces and encapsulation
    \item Classification and Polymorphism
\end{itemize}

Language concepts:
\begin{itemize}
    \item Classes
    \item Inheritance
    \item Subtyping
    \item Dynamic binding
\end{itemize}

Methods are invoked on a \receiver{} object:
\begin{example}[\receiver{}s]
Imagine there is a dog class and a human class. Here the dog instance is the \receiver{}.
\begin{lstlisting}[language=Java, escapechar=|]
    Dog dog = new Dog();
    Human human = new Human();
    dog.peeOn(human);
\end{lstlisting}
\end{example}
\section{Typing}

\subsection{Types}

\epigraph{\itshape Q: Why bother doing proofs about programming languages? They are almost always boring if the definitions are right. \\
A: The definitions are almost always wrong.}{Benjamin C. Pierce }

\begin{definition}[\nominal{} Types]
Type equivalence based on the type's name.
\end{definition}

\begin{definition}[\structural{} Types]
Type equivalence based on availability of methods and fields.
\end{definition}

\begin{definition}[\static{} Typing]
Types are determined at \compiletime{}, may be inferred or declared explicitly.
\end{definition}

\begin{definition}[\dynamic{} Typing]
Types are determined at \runtime{}.
\end{definition}

Sometimes \textit{\runtimecheck{}s} are needed even in so-called ``\static{}" languages.

\begin{example}[Downcasts]
Downcasts could fail so they need a \runtimecheck{}.
\begin{lstlisting}[language=Java, escapechar=|]
String foo(Object o){
    String s = (String) o;
    return s;
}
\end{lstlisting}
\end{example}

\subsection{Syntactic Subtyping}

\begin{definition}[\subprincip{}]
    Subtype objects may be used wherever supertype objects are expected.
\end{definition}

In languages such as Java and C\# we say a type is a subtype of another if it satisfies the rules \ref{fig:basicsubtype}.
\begin{figure}
\begin{mathpar}
  \boxed{\subtype{S}{T}}
  
  \inferrule
  {S ~ \text{extends} ~ T}
  {\subtype{S}{T}}

  \inferrule
  {S ~ \text{implements} ~ T}
  {\subtype{S}{T}}

  \inferrule
  { }
  {\subtype{T}{\top}}
  
  \inferrule
  { }
  {\subtype{T}{T}}

  \inferrule
  {\subtype{R}{S} \\ \subtype{S}{T}}
  {\subtype{R}{T}}
\end{mathpar}
\caption{Basic subtyping rules}
\label{fig:basicsubtype}
\end{figure}

\begin{definition}[\syntactic{} Subtyping]
Subtype \receiver{}s $S$ understand the messages of supertype \receiver{}s $T$.
\begin{equation}
    values(S) \subseteq values(T)
\end{equation}
$S$ has a wider interface than $T$.
\begin{equation}
    interface(T) \subseteq interface(S)
\end{equation}
We then say that $\subtype{S}{T}$.
\end{definition}

\begin{definition}[\nominal{} Subtyping]
$\subtype{S}{T}$ when $S$ explicitly declares $T$ as a supertype.
\end{definition}

\begin{definition}[\structural{} Subtyping]
$\subtype{S}{T}$ when $S$ has the same available methods and fields as $T$.
\end{definition}

For $\subtype{S}{T}$, then any field or method in $S$ that \override{}s one in $T$ must have at least the same visibility.

\begin{example}[Java Visibility]
\begin{equation}
    \subtype{\public{}}{\subtype{\protects}{\subtype{\default}{\private}}}
\end{equation}
\end{example}

\begin{definition}[Function Subtyping]
Recall from lambda calculi with subtyping that parameter types should be \textit{\contra{}} and that return types should be \textit{\covar{}}:
\begin{mathpar}
    \inferrule
    {\subtype{T_1}{S_1} \\
    \subtype{S_2}{T_2}}
    {\subtype{S_1 \rightarrow S_2}{T_1 \rightarrow T_2}}
\end{mathpar}
In OO this applies to methods.
\end{definition}

\begin{example}[Why \contra{} parameters?]
Consider the following:
\begin{lstlisting}[language=Java, escapechar=|]
class Animal {}

class Cat <: Animal {
    public void squish() { ... }
}

class Human {
    public void pet(Animal a) {}
}

class CatLover <: Human {
    public void pet(Cat c) {
        c.squish();
    }
}
\end{lstlisting}
We could have client code:
\begin{lstlisting}[language=Java, escapechar=|]
void client(Human h) {
    h.pet(new Animal())
}
\end{lstlisting}
That is called as:
\begin{lstlisting}[language=Java, escapechar=|]
client(new CatLover());
\end{lstlisting}
\end{example}
This would invoke \texttt{CatLover}'s pet method, which will call \texttt{squish} on an \texttt{Animal}. However we don't know if \texttt{Animal} in general may be squished? This message will not be understood.

In pretty-much all OO languages that anyone cares about return types are \covar{} but parameter types are \invar{} because this would make \textit{overloading} more troublesome.

\begin{definition}[Reference Subtyping]
Recall from lambda calculi with subtyping that mutable reference types must be \invar{}:
\begin{mathpar}
\inferrule
{\subtype{S}{T} \\
\subtype{T}{S}}
{\subtype{\mutref{S}}{\mutref{T}}}
\end{mathpar}
In OO this applies to class's mutable fields.
\end{definition}

\begin{example}[Why \invar{} fields?]
We can think of a mutable field has having a \texttt{read} and a \texttt{write} method.
\begin{lstlisting}[language=Java, escapechar=|]
class Super {
    T field;

    T read() {
        return this.field;
    }

    void write(T t) {
        this.field = t;
    }
}

class Sub <: Super {
    S field;

    S read() {
        return this.field;
    }

    void write(S s) {
        this.field;
    }
}
\end{lstlisting}
From doing function subtyping on \texttt{read} we get that $\subtype{S}{T}$. From doing function subtyping on \texttt{write} we get that $\subtype{T}{S}$.
\end{example}

Arrays in java are \covar{} because Java is stupid. So \textit{writes} to arrays require a \runtimecheck{}.

\begin{example}[\covar{} arrays in Java]
Consider the following:
\begin{lstlisting}[language=Java, numbers=left, escapechar=|]
String[] strs = {"hello", "world"};
Object[] objs = strs;
for (Object obj : objs) {
    System.out.println(obj);
}
System.out.println()
objs[0] = new Object(); |\label{line:covararry}|
\end{lstlisting}
This fails at line~\ref{line:covararry}. There is a \runtimecheck{} that throws a \\ \texttt{java.lang.ArrayStoreException} for array writes.
\end{example}

\begin{example}[\contra{} arrays?]
What if Java had \contra{} arrays? Consider:
\begin{lstlisting}[language=Java, numbers=left, escapechar=|]
Object[] objs = [new Object(), new Object()];
String strs = objs;
strs[0] = "hello";
for (int i = 0; i < strs.length(); i++) {
    System.out.println("bro" + strs[i]); |\label{line:contrarrread}| 
}
\end{lstlisting}
Here this would require a \runtimecheck{} at line~\ref{line:contrarrread} when we read from the array.
\end{example}

In general we want \covar{} for reads, or types in \textit{positive} positions whereas we want \contra{} for writes or types in \textit{negative} positions.
If what should be an \invar{} relation is treated as \covar{}, then we need a \runtimecheck{} for \textit{writes}.
If what should be an \invar{} relation is treated a \contra{}, then we need a \runtimecheck{} for \textit{reads}.

\begin{example}[Double pointers in C++]
  How should subtyping relate to pointers, and in particular double pointers?
  Consider the following, which assigns a value of \texttt{X} to what is passed into \texttt{init}.
\begin{lstlisting}[language=C++, escapechar=|]
class SuperX {};

class X : public SuperX {
    public: int a;
};

class SubX : public X {
    public: int b;
};

class Initializer {
    public:
        void init(X** x) {
            *x = new X();
        }
};
\end{lstlisting}
  For example we could use an \texttt{Initializer} to assign a non-\cringe{} value to a field of type \texttt{X*}.
\begin{lstlisting}[language=C++, escapechar=|]
class Value {
    private: X* x = nullptr;

    public: Value(Initializer* i) {
        i->init(&x); // The initializer object will set the value of x
    }
};
\end{lstlisting}
  Could we pass in values of type \texttt{SuperX} or \texttt{SubX} to \texttt{init}.
  May we have either of the following rules?
  \begin{mathpar}
    \inferrule*[right=\textsc{CovarDoublePtr}]
    {\subtype{S}{T}}
    {\subtype{S**}{T**}}

    \inferrule*[right=\textsc{ContraDoublePtr}]
    {\subtype{S}{T}}
    {\subtype{T**}{S**}}
  \end{mathpar}
  Let's test \textsc{CovarDoublePtr}.
  Consider if we modify \texttt{Value} as
\begin{lstlisting}[language=C++, escapechar=|]
class Value {
    private: SubX* x = nullptr;

    public: Value(Initializer* i) {
        i->init(&x); // The initializer object will set the value of x
        cout << x.b;
    }
};
\end{lstlisting}
  This will immediately fail when we try to perform \texttt{i->init(\&x)}.
  The method will attempt to assign a \texttt{X*} to a \texttt{SubX*}.
  This write fails because $\notsubtype{X}{SubX}$.
  This is equivalent to allowing:
\begin{lstlisting}[language=C++, escapechar=|]
class Initializer {
    public:
        void init(SubX** x) {
            *x = new X(); // obviously wrong
        }
};
\end{lstlisting}

  Let's instead test \textsc{ContraDoublePtr}.
  Consider if we modify both \texttt{Initializer} and \texttt{Value} as
\begin{lstlisting}[language=C++, escapechar=|]
class Initializer {
    public:
        void init(X** x) {
            cout << x.a;
            *x = new SubX();
        }
};

class Value {
    private: SuperX* x = new SuperX();

    public: Value(Initializer* i) {
        i->init(&x); // The initializer object will set the value of x
    }
};
\end{lstlisting}
  When \texttt{i->init(\&x)} is invoked, \texttt{init} will attempt to read field $a$ from what it thinks is an \texttt{X}.
  But because it is actually a \texttt{SuperX} it does not have an $a$.
  Thus this read fails.
  Thus the only safe rule for double pointers is an \textit{\invar{}} one.
  \begin{mathpar}
    \inferrule*[right=\textsc{InvarDoublePtr}]
    {\subtype{S}{T} \\ \subtype{T}{S}}
    {\subtype{S**}{T**}}
  \end{mathpar}
\end{example}

\begin{example}[Read only types]
  Types with values that may only be read from generally follow \textit{covariance}.
  Basic products (tuples) and sums (left or right) have simple rules.
  \begin{mathpar}
    \inferrule*[right=\textsc{ProductSubtyping}]
    {\subtype{S_1}{T_1} \\ \subtype{S_2}{T_2}}
    {\subtype{S_1 \times S_2}{T_1 \times T_2}}

    \inferrule*[right=\textsc{SumSubtyping}]
    {\subtype{S_1}{T_1} \\ \subtype{S_2}{T_2}}
    {\subtype{S_1 + S_2}{T_1 + T_2}}
  \end{mathpar}
  Record types (tagged products) and variant types (tagged sums) have a similar \textit{depth} subtyping rules.
  \begin{mathpar}
    \inferrule*[right=\textsc{RecordDepth}]
    {\subtype{S_1}{T_1} \\ ... \\ \subtype{S_n}{T_n}}
    {\subtype{\{ x_1 : S_1; ... ; x_n : S_n \}}{\{ x_1 : T_1; ... ; x_n : T_n \}}}

    \inferrule*[right=\textsc{VariantDepth}]
    {\subtype{S_1}{T_1} \\ ... \\ \subtype{S_n}{T_n}}
    {\subtype{\{ x_1 : S_1 | ... | x_n : S_n \}}{\{ x_1 : T_1 | ... | x_n : T_n \}}}
  \end{mathpar}
  However records and variants have different \textit{width} subtyping rules.
  A record type may subtype another if it has \textit{at least as many} members.
  This is analogous to subclasses having more fields than superclasses.
  A variant type may subtype another if it has \textit{at most as many} cases.
  If the opposite were allowed it would violate the \subprincip, as not all cases could be covered by code expecting the supertype.
  \begin{mathpar}
    \inferrule*[right=\textsc{RecordWidth}]
    { }
    {\subtype{ x_1 : T_1; ... ; x_n : T_n ; ... ; x_m : T_m }{ x_1 : T_1; ... ; x_n : T_n}}

    \inferrule*[right=\textsc{VariantDepth}]
    { }
    {\subtype{\{ x_1 : T_1 | ... | x_n : T_n \}}{\{ x_1 : T_1 | ... | x_n : T_n | ... | x_m : T_m \}}}
  \end{mathpar}
\end{example}

\begin{example}[Union types]
  Values of union types may take the form of any of its constituent types.
  These are different from variant types because they are not tagged.
  A union type may subtype another type if all of the constituent types are a subtype of some type in the supertype (How do I say this without ``type'' appearing so many times, suggestions welcome).
  \begin{mathpar}
    \inferrule*[right=\textsc{UnionSubtype}]
    {\forall i, \exists j, \subtype{S_i}{T_j}}
    {\subtype{\sum_{i}^{n} S_i}{\sum_{j}^{m} T_j}}
  \end{mathpar}
  When reasoning on paper it is easy to make mistakes when a given union type has several constituent types.
  When determining if a subtype relationship hold between two union types, it is sufficient to reduce each to the common super types among them.
  For example, observe that given $\subtype{B}{A}$, $\subtype{C}{B}$ and we have some type $A ~ || ~ B ~ || ~ C ~ || ~ D$, where $D$ is unrelated to the others,
  we can reduce $A ~ || ~ B ~ || ~ C ~ || ~ D$ to $A ~ || ~ D$.
\end{example}

\begin{example}[Dynamic types are screwy]
  If we know that some term $t$ has type $T$, $t : T$, in a normal language without subtyping we can make assumptions about the form $t$ takes.
  However in a setting with subtyping, knowing $t : T$ only tells us that there's some $S$ that $t$ really is, where $\subtype{S}{T}$.
  Consider a language that has a \texttt{MyType} to represent the \dynamic{} type of a term.
  We may define:
\begin{lstlisting}[language=Java, escapechar=|]
class Point {
    int x,y;

    boolean equals(MyType other) {
        return x == other.x && y == other.y;
    }
}

class ColorPoint extends Point {
    int color;
    override boolean equals(MyType other) {
        return super.equals(other) && color == other.color;
    }
}
\end{lstlisting}
  In these definitions we require that \dynamic{} type of the parameter of \texttt{equals} is a subtype of the dynamic type of \texttt{this}.
  This seems innocent enough.
  However this restriction is very screwy when you consider that some subclass of \texttt{Point} or \texttt{ColorPoint} may inherit \texttt{equals} and call it.
  In this setting we have no idea of the lower bound on \texttt{this}.
  Thus all of the following calls are bad:
\begin{lstlisting}[language=Java, escapechar=|]
Point p        = ...;
ColorPoint cp1 = ...;
ColorPoint cp2 = ...;

// Bad, p may be some other subtype of Point not related to ColorPoint
p.equals(cp1)

// Bad, p may be some other subtype of Point not related to ColorPoint
p.equals(cp2)

// Bad, p could be Point and cp1 could be ColorPoint
cp1.equals(p)

// Bad, cp2 could be some other subtype of ColorPoint
cp2.equals(cp1)

// Bad, cp1 could be some other subtype of ColorPoint
cp1.equals(cp2) 
\end{lstlisting}
  What if we make \texttt{ColorPoint} \texttt{final}; that is no class may \texttt{extend} \texttt{ColorPoint}.
\begin{lstlisting}[language=Java, escapechar=|]
final class ColorPoint extends Point {
    int color;
    override boolean equals(MyType other) {
        return super.equals(other) && color == other.color;
    }
}
\end{lstlisting}
  That helps us with the last two calls.
\begin{lstlisting}[language=Java, escapechar=|]
Point p        = ...;
ColorPoint cp1 = ...;
ColorPoint cp2 = ...;

// Bad, p may be some other subtype of Point not related to ColorPoint
p.equals(cp1)

// Bad, p may be some other subtype of Point not related to ColorPoint
p.equals(cp2)

// Bad, p could be Point and cp1 could be ColorPoint
cp1.equals(p)

// Okay, both must be ColorPoint
cp2.equals(cp1)

// Okay, both must be ColorPoint
cp1.equals(cp2) 
\end{lstlisting}
  Instead what if we could guarantee that a term has \textit{exactly} its declared type.
  Say the syntax is \texttt{@T t} where $t$ dynamically does not have a subtype of $T$.
  We could say the following
\begin{lstlisting}[language=Java, escapechar=|]
@Point p        = ...;
@ColorPoint cp1 = ...;
ColorPoint cp2  = ...;

// Okay, p must be Point
p.equals(cp1)

// Okay, p must be Point
p.equals(cp2)

// Bad, p is Point and cp1 is ColorPoint
cp1.equals(p)

// Bad, cp2 could be some other subtype of ColorPoint
cp2.equals(cp1)

// Okay, cp1 must be ColorPoint
cp1.equals(cp2) 
\end{lstlisting}
\end{example}

\subsection{Behavioral Subtyping}

\begin{definition}[Semantic Classification of Subtyping]
\begin{equation}
    \subtype{S}{T} \rightarrow behaviors(T) \subseteq behaviors(S)
\end{equation} 
\end{definition}

We would like to constrain how overriding method's pre- and postconditions may be logically related.

\begin{definition}[Overriding Preconditions]
Overriding methods may \textit{weaken} preconditions.
\begin{equation}
\subtype{S}{T} \rightarrow \forall ~ S_m ~ \override{} ~ T_m \rightarrow \pre{T_m} \rightarrow \pre{S_m}
\end{equation}
\end{definition}

\begin{definition}[Overrding Postconditions]
Overriding methods may \\ \textit{strengthen} postconditions.
\begin{equation}
\subtype{S}{T} \rightarrow \forall ~ S_m ~ \override{} ~ T_m \rightarrow \post{S_m} \rightarrow \post{T_m}
\end{equation}
We may allow a stronger result:
\begin{equation}
\subtype{S}{T} \rightarrow \forall ~ S_m ~ \override{} ~ T_m \rightarrow \old{\pre{T_m}} \rightarrow \post{S_m} \rightarrow \post{T_m}
\end{equation}
\end{definition}

These rules for pre- and postconditions are reminiscent of the \textit{rule of consequence} from Hoare Logic:
\begin{mathpar}
\inferrule
{P \rightarrow P' \\
\triple{P'}{c}{Q'} \\
Q' \rightarrow Q}
{\triple{P}{c}{Q}}
\end{mathpar}
We may think of $P$ as the precondition of the supertype, $Q$ as the postcondition of the supertype, $P'$ as the precondition of the subtype, and $Q'$ as the postcondition of the subtype.

\begin{definition}[Overriding Invariants]
Subtypes may have stronger class invariants for fields:
\begin{equation}
\subtype{S}{T} \rightarrow \inv{S} \rightarrow \inv{T}
\end{equation}
\end{definition}

\begin{definition}[History Constraints]
Properties of class fields that describe how objects evolve over time.
Such a relation on a class's field must be \textit{reflexive} and \textit{transitive}.
\begin{equation}
\constraint{T_f} := \old{T_f} \sqsubseteq T_f 
\end{equation}
where $\sqsubseteq$ is reflexive and transitive.
Relations in history constraints may be represented as pure boolean functions.
\end{definition}

\begin{example}[History Constraint]
Consider a stopwatch class that has the time.
\begin{lstlisting}
class Stopwatch {
    // constraint: old(time) <= time
    int time;

    void tick() {
        this.time++;
    }
}
\end{lstlisting}
\end{example}

\begin{definition}[Overriding History Constraints]
Subtypes may \textit{strengthen} history constraints for fields.
\begin{equation}
\subtype{S}{T} \rightarrow \forall ~ S_f ~ \override{} ~ T_f \rightarrow \constraint{S_f} \rightarrow \constraint{T_f}
\end{equation}
\end{definition}

\begin{example}[Unique key generation]
  We may specify a class that generates unique keys as an incrementing counter, that is keys it has not generated before, as follows
\begin{lstlisting}[language=Java, escapechar=|]
class IncCounter {
    // constraint old(key) <= key
    int key;

    IncCounter (int k) {
        this.key = k;
    }

    // ensures key = old(key) + 1 /\ result = old(key)
    int generate () {
        return this.key++;
    }
}
\end{lstlisting}
  The conjunction of the history constraint and postcondition of \texttt{generate} ensure that it actually generates new keys.
  Of course we are assuming no overflow.
  We could do something similar with a decrementing counter.
\begin{lstlisting}[language=Java, escapechar=|]
class DecCounter {
    // constraint key <= old(key)
    int key;

    DecCounter (int k) {
        this.key = k;
    }

    // ensures key + 1 = old(key) /\ result = old(key)
    int generate () {
        return this.key--;
    }
}
\end{lstlisting}
  Each is acceptable as a unique key generator, but neither is a behavioral subtype of the other.
  We may unify each with a common abstract class.
  A first attempt at generalizing some transitive relation to be used for uniqueness and a reflexive closure of that relation is as follows.
\begin{lstlisting}[language=Java, escapechar=|]
abstract class GenerateUniqueKey {
    // constraint reflTransRel(old(key),key)
    int key;

    // Some transitive relation.
    boolean transRel(int, int);

    // The reflexive closure of the transitive relation.
    boolean reflTransRel(int x, int y) {
        return transRel(x, y) || x == y
    }

    // ensures transRel(old(key), key) /\ result = old(key)
    int generate ();
}

class IncCounter extends GenerateUniqueKey {
    // constraint old(key) <= key
    int key;

    IncCounter (int k) {
        this.key = k;
    }

    boolean transRel(int x, int y) {
        return x < y
    }

    // ensures key = old(key) + 1 /\ result = old(key)
    int generate () {
        return this.key++;
    }
}

class DecCounter extends GenerateUniqueKey {
    // constraint key <= old(key)
    int key;

    DecCounter (int k) {
        this.key = k;
    }

    boolean transRel(int x, int y) {
        return y < x
    }

    // ensures key + 1 = old(key) /\ result = old(key)
    int generate () {
        return this.key++;
    }
}
\end{lstlisting}
  A more precise version is as follows.
\begin{lstlisting}[language=Java, escapechar=|]
abstract class GenerateUniqueKey {
     // constraint forall z, old(used(z)) -> used(z)

     abstract boolean used (int);

     // ensures ~ old(used(result)) /\ used(result)
     int generate ();
}

class IncCounter extends GenerateUniqueKey {
    // constraint old(key) <= key
    int key;

    IncCounter (int k) {
        this.key = k;
    }

    boolean used (int z) {
        return z < this.key;
    }

    // ensures key = old(key) + 1 /\ result = old(key)
    int generate () {
        return this.key++;
    }
}

class DecCounter {
    // constraint key <= old(key)
    int key;

    DecCounter (int k) {
        this.key = k;
    }

    boolean used (int z) {
        return this.key < z;
    }

    // ensures key + 1 = old(key) /\ result = old(key)
    int generate () {
        return this.key--;
    }
}
\end{lstlisting}
  Note that the history constraint is defined in terms of some function \texttt{used}.
  This is okay as long as \texttt{used} \textit{does not produce side effects}.
  Also note that we have \old{} wrapped around the result of a function without any fields.
  \old{used(z)} means any previous value \texttt{used} gave for $z$.
  The history constraint means that any int was used in the past, it is still used.
  We can show that \texttt{IncCounter} and \texttt{DecCounter} are behavioral subtypes of \texttt{GenerateUniqueKey}.
  For instance we can show that \texttt{IncCounter}'s history constraint is stronger than \texttt{GenerateUniqueKey}'s.
  \begin{align*}
    &\vdash \old{key} \leq key \rightarrow \forall z, \old{used(z)} \rightarrow used(z) \\
    \old{key} \leq key, \old{used(z)} &\vdash used(z) \\
    \old{key} \leq key, \old{z < key} &\vdash z < key \\
    \old{key} \leq key, z < \old{key} &\vdash z < key \\
  \end{align*}
  We can demonstrate that \texttt{DecCounter}'s history constraint is okay similarly.
  We can also show that \texttt{IncCounter.generate}'s postcondition is stronger than \texttt{GenerateUniqueKey.generate}'s.
  \begin{align*}
    \vdash key = \old{key} + 1 \wedge result = \old{key} &\rightarrow \neg \old{used(result)} \wedge used(result) \\
    key = \old{key} + 1, result = \old{key} &\vdash \neg \old{used(result)} \wedge used(result) \\
    key = \old{key} + 1, result = \old{key} &\vdash \neg \old{result < key} \wedge result < key \\
    key = \old{key} + 1, result = \old{key} &\vdash \neg result < \old{key} \wedge result < key \\
    key = \old{key} + 1, result = \old{key} &\vdash  \old{key} \leq result \wedge result < key \\
    &\vdash result \leq result \wedge result < result + 1
  \end{align*}
\end{example}

\begin{example}[Correctness properties and subtyping trickery]
  Other than pre- and postconditions, invariants, and history constraints, an exam may ask you to consider some other correctness property and how it should interact with subtyping.
  The property's definition may seem innocent, and may very well be well-defined on its own.
  However in the presence of subtyping it may be exploited to build adversarial programs that despite satisfying the basic requirements of this property will misbehave.
  Consider a property for ensuring that a function will terminate via some \textit{termination measure}.
  A termination measure must satisfy the following properties.
  \begin{itemize}
  \item It is an integer expression.
  \item It must have a non-negative value in each method call that satisfies the precondition.
  \item The only variables included are function's parameters.
  \item A function may only call another if the callee's termination measure is \textit{strictly less}.
  \end{itemize}
  A consequence of these rules is that a function may not call another if its termination measure is $0$.
  Consider the following valid and invalid implementations of a factorial.
\begin{lstlisting}[language=Java, escapechar=|]
interface Factorial {
    // requires 0 <= n
    // decreases n
    int factorial (int n);


}

class ValidFactorial implements Factorial {
    // requires 0 <= n
    // decreases n
    int factorial (int n) {
        // valid because n - 1 < n /\ 0 <= n - 1
        return 0 < n ? n * this.factorial(n - 1) : 1;
    }
}

class InvalidFactorial1 implements Factorial {
    // requires 0 <= n
    // decreases n
    int factorial (int n) {
        // invalid because ~ n < n
        return this.factorial(n);
    }
}

class InvalidFactorial1 implements Factorial {
    // requires 0 <= n
    // decreases n
    int factorial (int n) {
        // invalid because exists n, n - 1 < 0
        return this.factorial(n - 1);
    }
}
\end{lstlisting}
  Thus at face value it seems that the given definition is sufficient.
  However it is possible to write a non-terminating program that satisfies these conditions when we use subtyping.
  Consider the following;
\begin{lstlisting}[language=Java, escapechar=|]
class ExploitFactorial implements Factorial {
    // requires 0 <= n
    // decreases n + 1
    int factorial (int n) {
        Factorial fact = new ExploitFactorial();
        // valid because n < n + 1 /\ 0 <= n
        return fact.factorial(n);
    }
}
\end{lstlisting}
  The above will recurse until stack overflow.
  To prevent this we need to ensure the following property about a \texttt{decreases} clause.
  $$\subtype{S}{T} \rightarrow \forall ~ S_m ~ \override{} ~ T_m \rightarrow \pre{T_m} \rightarrow 0 \leq decreases(S_m) \leq decreases(T_m)$$
\end{example}

\section{Inheritance}

\epigraph{\itshape Inheritance is not a core concept [of OOP].}{Peter M\"uller}

\epigraph{\itshape Specifically, programming without inheritance is distinctly not object-oriented; that would merely be programming with abstract data types.}{Grady Booch}

Subtyping expresses \textit{classification}, whereas inheritance is a means of \textit{code reuse}. \textit{Subclassing} is both subtyping and inheritance. In inheritance there is only 1 super object at \runtime{} The sub object \textit{is} an instance of the super object. In aggregation an object \textit{has} another object as a field, and delegates to that object. It's possible to simulate subclassing with subtyping and delegation.

\begin{example}[Immutabe and Mutable Types]
Consider the following java code for an immutable cell:
\begin{lstlisting}[language=Java, escapechar=|]
class ImmutableCell {

    // constraint: old(val) = val
    private int val;
    
    public ImmutableCell (int val) {
        this.val = val;
    }

    public int get () {
        return this.val;
    }
}
\end{lstlisting}
We could want to write a mutable cell. How should it be related to \\ \texttt{ImmutableCell}?
Ideally a \texttt{MutableCell} could inherit all of \texttt{ImmutableCell}'s functionality and add a setter:
\begin{lstlisting}[language=Java, escapechar=|]
class MutableCell extends ImmutableCell {

    public MutableCell (int val) {
        super(val);
    }

    public void set (int val) {
        this.val = val;
    }
}
\end{lstlisting}
However \texttt{MutableCell} breaks the history constraint on \texttt{val}, so it cannot be a \behavioral{} subtype! In Java it would be best to use aggregation:
\begin{lstlisting}[language=Java, escapechar=|]
class MutableCell {
    ImmutableCell cell;

    public MutableCell (int val) {
        this.cell = new ImmutableCell(val);
    }

    public int get () {
        this.cell.get();
    }

    public void set (int val) {
        this.cell = new ImmutableCell(val);
    }
}
\end{lstlisting}
Admittedly this is stupid: it could just have an \texttt{int} field and do away with the overhead of storing another object.
\end{example}

\begin{example}[Private Inheritance]
In C++ it's possible for a class to inherit \textit{privately} from another class. This achieves code reuse without introducing a subtyping relation. Now we can implement the immutable and mutable cell example as we wanted to before.
\begin{lstlisting}[language=C++, escapechar=|]
class ImmutableCell {
    private:
        // constraint: old(val) = val
        int val;

    public:
        ImmutableCell (int v) {
            val = v;
        }

        int get () {
            return val;
        }
};

class MutableCell : private ImmutableCell {
    public:
        MutableCell (int v) : ImmutableCell(v) {}

        ImmutableCell::get

        void set (int v) {
            val = v;
        }
}
\end{lstlisting}
\end{example}

\subsection{Dynamic Method Binding}

\epigraph{\itshape The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code.}{Paul Graham}

\begin{definition}[Static binding]
At \compiletime{} a method is selected based on the \textit{\static{}} type of the \receiver{}'s \textit{\syntactic{}} expression.
\end{definition}

\begin{definition}[Dynamic binding]
At \runtime{} a method is selected based on the \textit{\dynamic{}} type of the \receiver{} object's \textit{value}.
\end{definition}

Java and Scala have \dynamic{} binding by default, whereas C++ and C\# have \static{} binding by default.

\begin{definition}[Two-step Method]
\label{twostep}
Given a method call on some \receiver{},
 to determine what method will be called given an OO program do:
\begin{enumerate}
\item Find the best-matching method based on the \textit{\static{}} type of the \receiver{} and arguments.
\item Based on the \textit{\dynamic{}} type of \receiver{} see if this method is overriden.
\end{enumerate}
This is different in each language. In Java for step 1 any method in the \static{} class and any of its superclass's are equally valid options. In C++ and C\# it starts at the \static{} type of the \receiver{} and goes up the class hierarchy until a suitable method is found.
This is each languages \textit{overloading resolution}.
\end{definition}

\begin{definition}[Fragile Base-class Scenario]
\label{fragile}
In general any potentially overriden methods may cause problems. A subclass's behavior may be affected by changes to the superclass, and the way a subclass overrides a superclass may break the superclass's behavior. In particular:
\begin{itemize}
\item A superclass should not change calls to \dynamic{}ally bound methods.
\item subclass's should \override{} any method that would otherwise break an invariant.
\item A superclass should never call a \dynamic{}ally bound method in a constructor.
\item Adding an overloading method to a superclass may affect the subclass (particularly in Java).
\end{itemize}
\end{definition}

In general a superclass does \textit{not} know what method may be invoked at \runtime{} for any overridable method.

In C++ and C\# a superclass may declare a method as \texttt{virtual} if a subclass may override it. In C\# a subclass may specify a method with \texttt{\override{}} if a superclass declares it with \texttt{virutal}. In C\# a subclass may specify a method with \texttt{new} if it wants to specify that the method doesn't have anything to do with the superclass's method; it does not override and it has different behavior.

\begin{example}[Overloading in Java]
  The below Java code will succeed.
\begin{lstlisting}[language=Java, escapechar=|]
class Person {
    protected double salary;
    
    public Person(double salary) {
        this.salary = salary;
    }

    public boolean haveSameIncome(Person other) {
        return this.salary == other.getIncome();
    }

    public double getIncome() {
        return salary;
    }
}

class MarriedPerson extends Person {
    private double spouseSalary;

    public MarriedPerson(double salary, double spouseSalary) {
        super(salary);
        this.spouseSalary = spouseSalary;
    }
    
    public boolean haveSameIncome(MarriedPerson other) {
        return this.getIncome() == other.getIncome();
    }
    
    public double getIncome() {
        return ((salary + spouseSalary) / 2);
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new MarriedPerson(0,4);
        MarriedPerson p2 = new MarriedPerson(2,2);
        assert p1.getIncome() == p2.getIncome();
        assert !p1.haveSameIncome(p2);
    }
}
\end{lstlisting}
  \texttt{p1.haveSameIncome(p2)} is false because when Java decides which method to call it looks first at the \static{} type of the \receiver{} $p_1$.
  \texttt{Person.haveSameIncome} is not \override{}n by \texttt{MarriedPerson.haveSameIncome} because the parameter types are different.
  If the parameter type of \texttt{MarriedPerson.haveSameIncome} were \texttt{Person} instead of \texttt{MarriedPerson} then it would be an \override{} and \texttt{p1.haveSameIncome(p2)} would be true.
  C\# works the same way here.
\end{example}

\begin{example}[Overloading in Java vs C\#]
  The following Java code will print ``X''.
\begin{lstlisting}[language=Java, escapechar=|]
class A {}

class B extends A {}

class X {
    void foo(B b) {
        System.out.println("X");
    }
}

class Y extends X {
    void foo(A a) {
        System.out.println("Y");
    }
}


public class Main {
    public static void main(String[] args) {
        Y y = new Y();
        y.foo(new B());
    }
}
\end{lstlisting}
  Even though \static{}ally $y$ is a $Y$ Java will find the most specific method given the \static{} types of the arguments.
  In this case \texttt{X.foo(B)} is more specific than \texttt{Y.foo(A)}.
  Conversely the analogous example in C\# will print ``Y''.
\begin{lstlisting}[language={[Sharp]C}, escapechar=|]
using System;

class A {}

class B : A {}

class X {
    public virtual void foo(B b) {
        Console.WriteLine("X");
    }
}

class Y : X {
    public void foo(A a) {
        Console.WriteLine("Y");
    }
}


public class Program {
    public static void Main(string[] args) {
        Y y = new Y();
        y.foo(new B());
    }
}
\end{lstlisting}
  C\# doesn't consider the \static{} type's methods equally to those of its supertypes.
  It starts at the \static{} type and if it finds a suitable method it chooses that.
  Note that ``X'' will be printed instead if the \static{} type of $y$ is changed to $X$.
\end{example}

\subsubsection{Binary Methods and the Visitor Pattern}

A Binary method takes the \receiver{} and one parameter (usually of the same type or one related in a subtype hierarchy). We want behavior to depend on the \textit{\dynamic{}} types of both. However simple overriding is not sound because parameter types should be \contra{}.

\begin{example}[Equals]
Consider that when we want to invoke an \texttt{equals} method we would like to have the most specialized version invoked.
\begin{lstlisting}[language=Java, escapechar=|]
class Animal {
    public boolean equals (Animal a) { ... }
}

class Cat extends Animal {
    public boolean equals (Cat c) { ... }
}
\end{lstlisting}
\texttt{Cat}'s \texttt{equals} does \textit{not} \override{} \texttt{Animal}'s. \texttt{Cat}'s \texttt{equals} \textit{overloads} \texttt{Animal}'s.
Consider:
\begin{lstlisting}[language=Java, escapechar=|]
Cat c1 = new Cat();
Cat c2 = new Cat();
Animal a1 = c1;
Animal a2 = c2;
a1.equals(a2);
\end{lstlisting}
Here \texttt{Animal}'s \texttt{equals} method is called even though \texttt{Cat}'s would be safe and what we want.
If we allowed an override than the following unsafe code would be accepted:
\begin{lstlisting}[language=Java, escapechar=|]
Cat c = new Cat();
Animal a = new Animal();
c.equals(a);
\end{lstlisting}
Since method resolution is determined by the \dynamic{} type of the \receiver{} \texttt{c}, \texttt{Cat}'s \texttt{equals} could be called which makes bad assumptions about its parameter in this case. What we would like is resolution to be determined by both the \dynamic{} type of the \receiver{} and that of its argument.
\end{example}

In languages such as Java, C++, and C\# how does one specialize behavior based on the \dynamic{} type of both the \receiver{} and that of its argument?

\begin{example}[Type tests]
We can check the type of the parameter:
\begin{lstlisting}[language=Java, escapechar=|]
class Cat extends Animal {
    public boolean equals (Animal a) {
        if (a instanceof Cat) {
            Cat c = (Cat) a;
            ...
        } else {
            return super.equals(a);
        }
    }
}
\end{lstlisting}
\end{example}

\begin{example}[Double invocation]
Both the super and subclass may have appropriate methods to dispatch to depending on the parameter types.
Consider the following:
\begin{lstlisting}[language=Java, escapechar=|]
class Animal {
    public boolean equals (Animal a) {
        // Give up
        return a.equalsAnimal(this);
    }

    // Terminal method
    public boolean equalsAnimal(Animal a) {
        // General for all Animals, Gives up
        ...
    }

    public boolean equalsBirb(Birb b) {
        // Give up
        return this.equalsAnimal(b);
    }

    public boolean equalsCat(Cat c) {
        // Give up
        return this.equalsAnimal(c);
    }
}

class Birb extends Animal {
    public boolean equals (Animal a) {
        return a.equalsBirb(this);
    }

    public boolean equals (Birb b) {
        // Specific code for Birbs
        ...
    }
}

class Cat extends Animal {
    public boolean equals (Animal a) {
        return a.equalsCat(this);
    }

    public boolean equalsCat(Cat c) {
        // Specific code for Cats
        ...
    }
}
\end{lstlisting}
In general if we want to specialize a binary method $m : \receiver{} \times T \rightarrow A$ where there is a super class $T$ and subclasses $S_i$, $\forall i, \subtype{S_i}{T}$, we need the following:
\begin{itemize}
\item $m \in T \wedge \forall i, m \in S_i$.
\item $\forall i, m_i : \receiver{} \times S_i \rightarrow A \wedge m_i \in T \wedge m_i \in S_i$
\item $m_{general} : \receiver{} \times T \rightarrow A \wedge m_{general} \in T$
\end{itemize}
Where $\in$ is used to denote a method is explicitly implemented in a particular class.
In Java $m_{general}$ is inherited by the $S_i$. $m \in T$ and each $m_i \in T$ will dispatch to $m_{general}$. $m$ in each $S_i$ will dispatch to $m_i$ flipping the arguments.
\end{example}

\begin{example}[Dynamic resolution in C\#]
C\# allows one to \dynamic{}ally resolve the calling method:
\begin{lstlisting}[language = {[Sharp]C}, escapechar=|]
class Animal {
    boolean equals (Animal a) {
        // General code for Animals
    }
}

class Cat : Animal {
    boolean equals (Cat c) {
        // Specific code for Cats
    }
}

static boolean equals (Animal a1, Animal a2) {
    return (a1 as dynamic).equals(a2 as dynamic);
}
\end{lstlisting}
\texttt{Cat}'s \texttt{equals} \textit{overloads} \texttt{Animal}'s. Which method is called depends on the \textit{\runtime{}} type of each argument. This requires \runtimecheck{}s.
\end{example}

\begin{example}[Multiple Dispatch]
Some (experimental) languages support \textit{multiple dispatch}.
\begin{lstlisting}[language=Java, escapechar=|]
class Animal {
    boolean equals (Animal a) {
        // General code for Animals
    }
}

class Cat : Animal {
    boolean equals (Animal@Cat c) {
        // Specific code for Cats
    }
}
\end{lstlisting}
In a call to \texttt{equals} the method is determined by the \dynamic{} type of the argument as well.
In \texttt{Cat}'s \texttt{equals}, the parameter \texttt{c} has \static{} type \texttt{Animal} and \textit{dispatch} type \texttt{Cat}. Every call needs to have a unique best method, or else typechecking fails.
\end{example}

\subsection{Multiple Inheritance}

\epigraph{\itshape I made up the term ``object-oriented," and I can tell you I did not have C++ in mind.}{Alan Kay}

\epigraph{\itshape C makes it easy to shoot yourself in the foot. In C++ it's harder, but when you do, you blow off your whole leg.}{Bjarne Stroustrup}

A type may have several subtypes and (direct) supertypes.
For instance, it makes sense to say $\subtype{Tabby}{Cat}$ and $\subtype{Tiger}{Cat}$, as well as $\subtype{Cat}{Animal}$ and that $\subtype{Cat}{Furball}$, where $Animal$ and $Furball$ are not necessarily related. Sometimes we would like to reuse code from several superclasses as well. In OOP, why not combine both into \textit{multiple inheritance}?

\begin{remark}\label{remark:multipleinheritancejava}
Java and C\# only support single inheritance but using aggregation may simulate single inheritance and interfaces.
\end{remark}

\begin{example}[Interfaces and subtyping]
  Sometimes Java is unable to tell \static{}ally if the \dynamic{} type of a term is a subtype of some interface.
  Consider the following program.
\begin{lstlisting}[language=Java, numbers=left, escapechar=|]
interface I {
    int foo ();
}

class C {}

public class Main {
    public static C getC() {
        return new C();
    }

    public static void main(String[] argv) {
        C c1 = new C();
        C c2 = getC();

        I i1 = (I) c1; |\label{line:Ii1Ic1}|
        System.out.println(i1.foo());
        I i2 = (I) c2; |\label{line:Ii2Ic2}|
        System.out.println(i2.foo());
    }
}
\end{lstlisting}
  The typechecker accepts the above code, even though $\notsubtype{C}{I}$.
  At \runtime{} an exception is thrown at line~\ref{line:Ii1Ic1} when attempting to cast $c_1$ to an $I$.
  If lines \ref{line:Ii1Ic1} until \ref{line:Ii2Ic2} are commented out then at \runtime{} an exception is thrown at line \ref{line:Ii2Ic2} when attempting to cast $c_2$ to an $I$.
  Why does Java accept this code if obviously $\notsubtype{C}{I}$?
  Because the \dynamic{} types of $c_1$ and $c_2$ could be some subtype of $I$.
  Java opts for flexibility and performs a \textit{\runtimecheck{}} in these cases.
  This is because Java \textit{does allow} for \textit{multiple subtyping}.
  For example we could instead have:
\begin{lstlisting}[language=Java, numbers=left, escapechar=|]
interface I {
    int foo ();
}

class C {}

class D extends C implements I {
    public int foo () { return 0; }
}

public class Main {
    public static C getC() {
        return new D();
    }

    public static void main(String[] argv) {
        C c1 = new D();
        C c2 = getC();

        I i1 = (I) c1; |\label{line:Ii1Ic12}|
        System.out.println(i1.foo());
        I i2 = (I) c2; |\label{line:Ii2Ic122}|
        System.out.println(i2.foo());
    }
}
\end{lstlisting}
  The above code compiles and prints $0$ twice.
  If $I$ had been declared as a class or an abstract class the casts on lines \ref{line:Ii1Ic12} and \ref{line:Ii2Ic122} would have been rejected by the typechecker.
  This is because Java \textit{does not} allow \textit{multiple subclassing}.
\end{example}

Multiple inheritance is just bad. Here's why.

\subsubsection{Ambiguities}

A subclass $S$ may inherit directly from both $T_1$ and $T_2$, and $T_1$ and $T_2$ may both have a field $f$ or method $m$. When an instance of $S$ is the \receiver{} for $m$ or $f$ how does it choose which one? The client may need to explicitly refer to which field or method. Sometimes methods may be combined into one overriding method in the subclass.

\subsubsection{Repeated Inheritance}

Sometimes a subclass $S$ inherits directly from both $T_1$ and $T_2$, where $T_1$ and $T_2$ both inherit directly from $Top$. $Top$ may have some field $f$. How many copies of $f$ should $S$ have? This is the infamous \textit{diamond problem}.

By default C++ has \textit{non-virtual} inheritance, where two copies of each $Top$ class exist in memory. The constructor for $Top$ is called twice, once for $T_1$, and once for $T_2$.

In C++ one may also inherit \textit{virtually}, where only one copy of $Top$ exists in memory and its constructor is just called once.
In this case, the smallest subclass $S$ must call the constructor for $Top$ directly.
If there is a constructor for $Top$ without arguments, this will be called first by default. Constructors should not realy upon the virutal superclass constructors they call to maintain invariants.

\begin{example}[Multiple inheritance in C++]
  Consider the following C++ code that implements an email folder.
\begin{lstlisting}[language=C++, numbers=left, escapechar=|]
#include <iostream>
#include <vector>

class Mail {
    public:
        bool isHighPriority() { return false; }
};

// a folder containing e-mails
class Folder {
    private:
        // e-mails in the folder
        std::vector<Mail> data;

    public:
        Folder() {
            std::vector<Mail> mails;
            this->data = mails;
            std::cout << "data created" << std::endl;
        }
    
        bool empty() {
            // returns true iff the folder is empty
            return this->data.empty(); |\label{line:folderempty}|
        } 

        void enqueue(Mail *m) {
            // adds an e-mail to the folder
            this->data.push_back(*m);        |\label{line:folderenqueue}|
        }

        Mail* dequeue() {
            if (this->empty()) {
                // returns null if the folder is empty
                return nullptr;
            }
            // otherwise, returns the top e-mail
            Mail* top = &(this->data[0]);
            this->data.erase(this->data.begin());
            return top;
        }
};

// low-priority e-mail filter
class LowPriority: public virtual Folder {
    public: LowPriority () {}
};

// high-priority e-mail filter
class HighPriority: public virtual Folder {
    public: HighPriority () {}
};

// inbox containing all unread e-mails, of any priority
class Inbox:
    public LowPriority, public HighPriority, public virtual Folder {
    public:
        Inbox () {}
    
        bool empty() {
            return this->Folder::empty();   |\label{line:inboxempty}|
        }
        
        void enqueue(Mail *m) {
            this->Folder::enqueue(m);       |\label{line:inboxenqueue}|
        }
        
        Mail *dequeue() {
            return this->Folder::dequeue(); |\label{line:inboxdequeue}|
        }
};

int main() {
    Inbox* inbox = new Inbox();
    return 0;
}
\end{lstlisting}
  The class hierarchy for \texttt{Inbox} goes as:
  \begin{itemize}
  \item \texttt{LowPriority} inherits \textit{virtually} from \texttt{Folder}.
  \item \texttt{HighPriority} inherits \textit{virtually} from \texttt{Folder}.
  \item \texttt{Inbox} inherits \textit{virtually} from \texttt{Folder}.
  \item \texttt{Inbox} inherits \textit{non-virtually} from \texttt{LowPriority}.
  \item \texttt{Inbox} inherits \textit{non-virtually} from \texttt{HighPriority}.
  \end{itemize}
  When \texttt{inbox} is initialized, ``data created'' will only be printed once since \texttt{Inbox}, via itself and \texttt{LowPriority} and \texttt{HighPriority} will only have allocated memory for one \texttt{Folder}, since it is inherited virtually.
  In an instance of \texttt{Inbox} it, its \texttt{LowPriority}, and its \texttt{HighPriority} all share one instance of \texttt{Folder}.
  Note that \texttt{Inbox}'s methods \textit{do not \override{}} \texttt{Folder}'s.


  In fact \texttt{Inbox}'s direct virtual inherit from \texttt{Folder} is redundant.
  If \texttt{Inbox} did not inherit from \texttt{Folder} and say \texttt{LowPriority} instead non-virtually inherited from \texttt{Folder} the there would be ambiguity errors in \texttt{Inbox}'s method's bodies.


  If \texttt{Inbox} or \texttt{LowPriority} or \texttt{HighPriority} inherited non-virtually from \texttt{Folder} then the C++ compiler would reject the above code for being ambiguous.
  \texttt{Inbox} would not be allowed to inherit directly from \texttt{Folder} and even the inner method calls would be ambiguous.


  Our code and hierarchy seem fine, but consider the following additions:
\begin{lstlisting}[language=C++, numbers=left, escapechar=|]
// folder containing all read e-mails
class Archive: public virtual Folder {
    public: Archive () {}
};

class Client: public Inbox, public Archive {
        public:
            void receive(Mail *m) {
                this->Inbox::enqueue(m); |\label{line:clientreceive}|
            }
            
            void markAllAsRead() {
                while (!this->Inbox::empty()) {       |\label{line:whilenotempty}|
                    Mail *m = this->Inbox::dequeue(); |\label{line:clientdequeue}|
                    this->Archive::enqueue(m);        |\label{line:clientenqueue}|
                }
            }
};

void clientTest() {
    Client* client = new Client(); |\label{line:newclient}|
    client->receive(new Mail());   |\label{line:receivenewmail}|
    client->markAllAsRead();       |\label{line:invokemarkread}|
}

int main() {
    clientTest();
    return 0;
}
\end{lstlisting}
  The above code will not terminate.
  To see why let us consider the class hierarchy of \texttt{Archive} and \texttt{Client}.
  \begin{itemize}
  \item \texttt{Archive} inherits \textit{virtually} from \texttt{Folder}.
  \item \texttt{Client} inherits \textit{non-virtually} from \texttt{Inbox}.
  \item \texttt{Client} inherits \textit{non-virtually} from \texttt{Archive}.
  \item Via \texttt{Inbox}, \texttt{Client} inherits \textit{non-virtually} from \texttt{LowPriority}.
  \item Via \texttt{Inbox}, \texttt{Client} inherits \textit{non-virtually} from \texttt{HighPriority}.
  \item Via \texttt{Inbox}, \texttt{LowPriority}, \texttt{HighPriority}, and \texttt{Archive}, \texttt{Client} inherits \textit{virtually} from \texttt{Folder}. 
  \end{itemize}
Again for an instance of \texttt{Client} there is only one \texttt{Folder} so ``data created'' is printed only once.
  The code behaves the same way if we again remove \texttt{public virtual Folder} from \texttt{Inbox}.
  This was probably just meant to confuse people.

  The trouble comes from the invocation \texttt{client->markAllAsRead()}.
  In fact if \texttt{client->receive(new Mail())} is never called beforehand then \texttt{data} will be empty and the loop will never run.
  Let us follow the execution in \texttt{clientTest}.
  \begin{enumerate}
  \item On line~\ref{line:newclient} in \texttt{clientTest} \texttt{Client}'s constructor is invoked.
  \item The default constructor for \texttt{Folder} is called only once, initializing an empty \texttt{data}.
  \item The default constructor for \texttt{LowPriority} is called only once.
  \item The default constructor for \texttt{HighPriority} is called only once.
  \item The default constructor for \texttt{Inbox} is called only once.
  \item The default constructor for \texttt{Archive} is called only once.
  \item The call stack returns to \texttt{clientTest}.
  \item On line~\ref{line:receivenewmail} in \texttt{clientTest} \texttt{Client.recieve} is invoked.
  \item On line~\ref{line:clientreceive} in \texttt{Client.recieve} \texttt{this->Inbox::enqueue(m)} is invoked.
  \item On line~\ref{line:inboxenqueue} in \texttt{Inbox.enqueue} \texttt{this->Folder::enqueue(m)} is invoked.
  \item On line~\ref{line:folderenqueue} in \texttt{Folder.enqueue} \texttt{this->data.push\_back(*m)} is invoked.
  \item The call stack returns to \texttt{clientTest}.
  \item On line~\ref{line:invokemarkread} in \texttt{clientTest} \texttt{client->markAllAsRead()} is invoked.
  \item On line~\ref{line:whilenotempty} in \texttt{Client.markAllAsRead} \texttt{this->Inbox::empty()} is invoked.
  \item On line~\ref{line:inboxempty} in \texttt{Inbox.empty} \texttt{this->Folder::empty()} is invoked.
  \item On line~\ref{line:folderempty} in \texttt{Folder.empty} \texttt{this->data.empty()} is invoked and returns \texttt{false}.
  \item The call stack returns to \texttt{Client.markAllAsRead}, and the guard of the loop is \texttt{true}.
  \item On line~\ref{line:clientdequeue} in \texttt{Client.markAllAsRead} \texttt{this->Inbox::dequeue()} is invoked.
  \item On line~\ref{line:inboxdequeue} in \texttt{Inbox.dequeue} \texttt{this->Folder::dequeue()} is invoked.
  \item In \texttt{Folder.dequeue} the \texttt{Mail} that was initially put in \texttt{data} is popped out and returned.
  \item The call stack returns to \texttt{Client.markAllAsRead}, and \texttt{mail} is assigned to the returned \texttt{Mail}.
  \item On line~\ref{line:clientenqueue} in \texttt{Client.markAllAsRead} \texttt{this->Archive::enqueue(m)} is invoked.
  \item \texttt{Archive.enqueue} \textit{is} \texttt{Folder.enqueue}.
  \item In \texttt{Folder.enqueue} the \texttt{Mail} is added to \textit{the same data}.
  \item The call stack returns to \texttt{Client.markAllAsRead}.
  \item We loop to step 14.
  \end{enumerate}
  The code is attempting to ``\textit{read}'' each email from the inbox folder and then archive it.
  But because \texttt{Client}'s \texttt{Inbox} and \texttt{Archive} share the same \texttt{Folder} with the same \texttt{data}, the same mail keeps being pushed on and popped off the same stack and no progress is made reading through the emails.
  This example was designed to overwhelm the reader with extraneous classes and inheritance annotations.
  The following minimal example has the same behavior.
\begin{lstlisting}[language=C++, escapechar=|]
#include <iostream>
#include <vector>

class Mail {};

// a folder containing e-mails
class Folder {
    private:
        // e-mails in the folder
        std::vector<Mail> data;

    public:
        Folder() {
            std::vector<Mail> mails;
            this->data = mails;
            std::cout << "Folder init" << std::endl;
        }
    
        bool empty() {
            // returns true iff the folder is empty
            return this->data.empty();
        } 

        void enqueue(Mail *m) {
            // adds an e-mail to the folder
            this->data.push_back(*m);
        }

        Mail* dequeue() {
            if (this->empty()) {
                // returns null if the folder is empty
                return nullptr;
            }
            // otherwise, returns the top e-mail
            Mail* top = &(this->data[0]);
            this->data.erase(this->data.begin());
            return top;
        }
};

// inbox containing all unread e-mails, of any priority
class Inbox:
    public virtual Folder {
    public:
        Inbox () {
            std::cout << "Inbox init" << std::endl;
        }
    
        bool empty() {
            return this->Folder::empty();
        }
        
        void enqueue(Mail *m) {
            this->Folder::enqueue(m);
        }
        
        Mail *dequeue() {
            return this->Folder::dequeue();
        }
};

class Archive: public virtual Folder {
    public: Archive () {
        std::cout << "Archive init" << std::endl;
    }
};

class Client: public Inbox, public Archive {
        public:
            Client () {
                std::cout << "Client init" << std::endl;
            }
        
            void receive(Mail *m) { this->Inbox::enqueue(m); }
            
            void markAllAsRead() {
                while (!this->Inbox::empty()) {
                    Mail *m = this->Inbox::dequeue();
                    this->Archive::enqueue(m);
                }
            }
};

void clientTest() {
    Client* client = new Client();
    client->receive(new Mail());
    client->markAllAsRead();
}

int main() {
    clientTest();
    return 0;
}
\end{lstlisting}
  In these examples it is best to start by diagraming the inheritance structure, and then running the code.
\end{example}

\begin{remark}
  In C++, when a virtual class is extended by two subclasses, it doesn't matter the order of the other specified class extensions, the virtual classes are always instantiated before the others.
\end{remark}

\subsection{Linearization}

Scala has \textit{mixins} or \textit{traits} that may help specialize classes. Traits extend exactly one superclass and some number of traits. When mixing in a trait in a class declaration the class \textit{must} be a subclass of the direct superclass of each trait.

\begin{remark}\label{remark:linearremark}
$$\forall ~ \text{classes} ~ C, \text{traits} ~ T ~ \text{s.t.} ~ T ~ extends ~ C, \subtype{T}{C}$$
\end{remark}

The dynamic dispatch order is determined by \textit{linearization}.

\begin{definition}[Linearization]
$L$ determines the dispatch order.
\begin{align} 
L(C ~ extends ~ C' ~ with ~ T_1 ... ~ with ~ T_n) &=  C, L(T_n) \bullet ... \bullet L(T_1) \bullet L(C') \\
\varepsilon \bullet B &= B \\
(a, A) \bullet B &=
\begin{cases}
A \bullet B & a \in B \\
a, A \bullet B & a \notin B
\end{cases}
\end{align}
The initialization order is the opposite.
\end{definition}


A subclass only has one copy of a superclass in memory. In initialization each constructor is called exactly once, where arguments to a superclass constructor are provided by the immediately preceding class in the linearization order.

\behavioral{} subtyping can only be checked when a trait is mixed in. Traits are difficult to reason about because:
\begin{itemize}
\item Like in C++ virutal inheritance they don't know how their superclasses get initialized.
\item Traits do not know which methods they \override{}.
\item Traits do not know \static{}ally which class \texttt{super} calls will go to.
\end{itemize}

\begin{example}[Traits and (the lack of) \behavioral{} subtyping]
  One (futile) approach to ensure that traits follow \behavioral{} subtyping is to require that if a class $C$ has a specification $S$, and a trait $T$ extends $C$, then \texttt{C with T} must also abide by $S$.
  Consider the following counterexample.
\begin{lstlisting}[language=Scala, escapechar=|]
class C {
    // ensures x <= result <= x + 2
    def foo (x : Int) : Int = x + 1
}

trait T1 extends C {
    // ensures x <= result <= x + 2
    override def foo (x : Int) : Int = super.foo(x) + 1
}

trait T2 extends C {
    // ensures x <= result <= x + 2
    override def foo (x : Int) : Int = super.foo(x) + 1
}

object Main {
  def main(): Unit = {
    val a = new C with T1;
    val b = new C with T2;
    val x = 1;
    assert(x <= a.foo(x) && a.foo(x) <= x + 2); // ok
    assert(x <= b.foo(x) && b.foo(x) <= x + 2); // ok
    val c = new C with T1 with T2;
    assert(x <= c.foo(x) && c.foo(x) <= x + 2); // FAILS
  }
}

Main.main()
\end{lstlisting}
  Even though the postcondition is satisfied for \texttt{C with T1} and \texttt{C with T2} once we mix in multiple traits that satisfy the spec we get problems.
  Issues with Scala's linearization and \behavioral{} subtyping usually emerge when two traits are mixed in and each interacts with the \texttt{super}'s methods.
\end{example}

\section{More Typing}

\epigraph{\itshape If Sun were to hand the management of Java over to a committee of monkeys, would it be more successful?}{Eric Sink}

\subsection{Bytecode Verification}

The Java Virtual Machine (JVM) runs \textit{java bytecode}. In order to make some guarantees about some arbitrary bytecode loaded by a program, the bytecode must be typechecked.

\begin{definition}[Java Virtual Machine]
JVM is a stack-based language that consists of the following:
\begin{itemize}
\item A stack (duh). Operations push elements onto the stack and pop them off.
\item A (potentially finite) set of registers. The first stores \texttt{this}, then method parameters, then local variables.
\item A heap where objects are stored in memory. The stack and registers may have pointers to the heap.
\end{itemize}
\end{definition}

A sample of the JVM instruction set is provided in \ref{fig:JVMinstr}.
\begin{figure}
\centering
$\begin{array}{r c l l}
\instr{}
& ::= & \const{z} & \text{push \texttt{int} $z$ onto the stack} \\
& \mid & \load{\tau}{r} & \text{push value in register $r$ onto the stack} \\
& \mid & \store{\tau}{r} & \text{pop top value from stack into register $r$} \\
& \mid & \op{\otimes} & \text{pop top 2 values $v_1, v_2$ from stack and push $v_1 \otimes v_2$} \\
& \mid & \invokev{C}{m}{\tau_r (\tau_1, ..., \tau_n)} & \text{pop args $v_n, ..., v_1$ \receiver{} $v$ then push $C.m.v(v_1,...,v_n)$}  \\
& | & \invokei{I}{m}{\tau_r (\tau_1, ..., \tau_n)} & \text{pop args $v_n, ..., v_1$ \receiver{} $v$ then push $I.m.v(v_1,...,v_n)$}  \\
& \mid & \return{\tau} & \text{pop $v$ and method return $v$} \\
& | & \ifeq{l} & \text{pop $v$ and jump to $l$ if $v = 0$} \\
& \mid & \goto{l} & \text{jump to program line $l$}
\end{array}$
\caption{JVM instructions}
\label{fig:JVMinstr}
\end{figure}

JVM instructions are typechecked. There's a max stack size $MS$, input type list for the stack $S$, input type list for registers $R$, and output type list for the stack $S'$, and an output type list for the registers $R'$. Some of the basic rules are given in \ref{fig:JVMjudge}.

\begin{figure}
\centering
\begin{mathpar}
\boxed{\judge{MS}{\instr}{S}{R}{S'}{R'}} \\

\inferrule*[right=\textsc{Const}]
{|S| < MS}
{\judge{MS}{\const{z}}{S}{R}{\texttt{int}.S}{R}}

\inferrule*[right=\textsc{Load}]
{|S| < MS \\
\subtype{R(r)}{\tau}}
{\judge{MS}{\load{\tau}{r}}{S}{R}{\tau.S}{R}}

\inferrule*[right=\textsc{Store}]
{\subtype{\tau'}{\tau} \\
R'(r) = \tau}
{\judge{MS}{\store{\tau}{r}}{\tau'.S}{R}{S}{R'}}

\inferrule*[right=\textsc{Op}]
{1 + |S| < MS \\
\otimes : \tau_1 \times \tau_2 \rightarrow \tau \\
\subtype{\tau_1'}{\tau_1} \\
\subtype{\tau_2'}{\tau_2}}
{\judge{MS}{\op{\otimes}}{\tau_1'.\tau_2'.S}{R}{\tau.S}{R}}

\inferrule*[right=\textsc{InvokeVirutal}]
{n + |S| < MS \\
\subtype{\tau'}{C} \\
\subtype{\tau_1'}{\tau_1} ~ ... ~ \subtype{\tau_n'}{\tau_n} \\
}
{\judge{MS}{\invokev{C}{m}{\tau_r (\tau_1, ..., \tau_n)}}{\tau_n'...\tau_1'.\tau'.S}{R}{\tau_r.S}{R}} \\

\inferrule*[right=\textsc{InvokeInterface}]
{n + |S| < MS \\
\subtype{\tau'}{Object} \\
\subtype{\tau_1'}{\tau_1} ~ ... ~ \subtype{\tau_n'}{\tau_n} \\
}
{\judge{MS}{\invokei{I}{m}{\tau_r (\tau_1, ..., \tau_n)}}{\tau_n'...\tau_1'.\tau'.S}{R}{\tau_r.S}{R}} \\

\inferrule*[right=\textsc{IfEq}]
{ }
{\judge{MS}{\ifeq{l}}{\texttt{int}.S}{R}{S}{R}}

\inferrule*[right=\textsc{Goto}]
{ }
{\judge{MS}{\goto{l}}{S}{R}{S}{R}}

\inferrule*[right=\textsc{Return}]
{\subtype{\tau'}{\tau}}
{\judge{MS}{\return{\tau}}{\tau'.S}{R}{\emptyset}{\emptyset}}
\end{mathpar}
\caption{JVM instruction typing}
\label{fig:JVMjudge}
\end{figure}

\begin{remark}\label{remark:javaisdumb}
Note that the rule for stores does not check that the previous type in the register is related. Thus bytecode typing allows strong updates, something not allowed in java source code.
\end{remark}

Instructions may have several predecessors because of jumps. Thus the \textit{smallest common supertype}, or \textit{join} $\sqcup$ needs to be selected.

\begin{remark}\label{remark:interfacesaredumb}
  With multiple subtyping (such as with interfaces in Java) it may not be possible to calculate the join. A \runtimecheck{} is necessary for interface method invocation.
  This is why the rule for \texttt{invokeinterface} does not check that the expected type on the static satisfies the interface, only that it is a Object.
\end{remark}

(Old) Java needed to perform type inference on bytecode. Because joins need to be computed, a \textit{worklist algorithm} is necessary.
In this dataflow analysis, for each instruction $\instr{}(p)$ at a program point (line) $p$, we have $\wkin{p}$ for the types of the stack and registers before the instruction, and $\wkout{p}$ for the types of the stack and registers after the instruction.
Thus we have:

\begin{equation}
\instr{}(p) : \wkin{p} \rightarrow \wkout{p}
\end{equation}

The dataflow equation we solve for is:

\begin{equation}
\wkin{p} = \bigsqcup \{ \wkout{q} \mid q ~ \text{precedes} ~ p \}
\end{equation}

We want to take all of the predecessor instructions of $p$, take the joins of their types in their stacks and registers.
This join is exactly what we want to compute for $\wkin{p}$.

To start out we want the stack to be empty, and the registers to contain the known parameter types $P_i$ and $\top$ for the local variables. The algorithm is given in \ref{alg:worklist}. Note that $\sqcup$ fails for different stack sizes.

\begin{algorithm}
\caption{JVM Type Inference}\label{alg:worklist}
\begin{algorithmic}
\State $\wkin{0} \gets (\varepsilon, [P_1, ..., P_n, \top, ..., \top])$
\State $worklist \gets \{ p \mid \instr{}(p) ~ \text{in method} \}$
\While{$worklist \neq \emptyset$}
\State $p \gets \min{worklist}$
\State $worklist \gets worklist \setminus \{ p \}$
\State $\instr{}(p) : \wkin{p} \rightarrow \wkout{p}$ \Comment{Apply rule to get $\wkout{p}$}
\ForAll{$q$ succeeding $p$}
    \State $\wkin{q} \gets \wkin{q} \sqcup \wkout{p}$
    \If{$\wkin{q}$ has changed}
        \State $worklist \gets worklist \cup \{ q \}$
    \EndIf
\EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

\href{https://www.irisa.fr/celtique/teaching/SOS/2021/Leroy-bytecode-verification-JAR.pdf}{Read this to learn more about java bytecode verification.}

\begin{example}[Bytecode verification example]
  Suppose we have a class hierarchy $\subtype{D}{C}$ and $\subtype{E}{C}$.
  Consider the program:
\begin{lstlisting}[language=JVMIS, numbers=left, firstnumber=0, escapechar=|]
aload 0;
astore 2;
aload 1;
goto 1;
\end{lstlisting}
  Lets say that the signature that the start of the program is $[], [D,E,\top]$,
  so we set $\wkin{0} = [], [D,E,\top]$.
  The worklist at first has all instructions in order.
  \begin{enumerate}
  \item We pop instruction $\instr{}(0) = \texttt{aload 0}$ from the worklist.
    We have $\wkin{0} = [], [D,E,\top]$.
    Applying \textsc{Load} we get $\wkout{0} = [D], [D,E,\top]$.
    The only successor of $\instr{}(0) = \texttt{aload 0}$ is $\instr{}(1) = \texttt{astore 2}$.
    Since we do not yet have $\wkin{1}$ we set it as $\wkin{1} = \wkout{0} = [D], [D,E,\top]$.
    Since $\wkin{1}$ has changed we still need $\instr{}(1) = \texttt{astore 2}$ in the worklist.
  \item We pop instruction $\instr{}(1) = \texttt{astore 2}$ from the worklist.
    We have $\wkin{1} = [D], [D,E,\top]$.
    Applying \textsc{Store} we get $\wkout{1} = [], [D,E,D]$.
    The only successor of $\instr{}(1) = \texttt{astore 2}$ is $\instr{}(2) = \texttt{aload 1}$.
    Since we do not yet have $\wkin{2}$ we set it as $\wkin{2} = \wkout{1} = [], [D,E,D]$.
    Since $\wkin{2}$ has changed we still need $\instr{}(2) = \texttt{aload 1}$ in the worklist.
  \item We pop instruction $\instr{}(2) = \texttt{aload 1}$ from the worklist.
    We have $\wkin{2} = [], [D,E,D]$.
    Applying \textsc{Load} we get $\wkout{2} = [E], [D,E,D]$.
    The only successor of $\instr{}(2) = \texttt{aload 1}$ is $\instr{}(3) = \texttt{goto 1}$.
    Since we do not yet have $\wkin{3}$ we set it as $\wkin{3} = \wkout{2} = [E], [D,E,D]$.
    Since $\wkin{3}$ has changed we still need $\instr{}(3) = \texttt{goto 1}$ in the worklist.
  \item We pop instruction $\instr{}(3) = \texttt{goto 1}$ from the worklist.
    We have $\wkin{3} = [E], [D,E,D]$.
    Applying \textsc{Goto} we get $\wkout{3} = [E], [D,E,D]$.
    The only successor of $\instr{}(3) = \texttt{goto 1}$ is $\instr{}(1) = \texttt{astore 2}$.
    We assign $\wkin{1}$ as:
    \begin{align*}
      \wkin{1} &= \wkin{1} \sqcup \wkout{3} \\
               &= ([D], [D,E,\top]) \sqcup ([E], [D,E,D]) \\
               &= [D] \sqcup [E], [D,E,\top] \sqcup [D,E,D] \\
               &= [D \sqcup E], [D \sqcup D, E \sqcup E, \top \sqcup D] \\
               &= [C], [D, E, \top]
    \end{align*}
    Since $\wkin{1}$ has changed we add $\instr{}(1) = \texttt{astore 2}$ back into the worklist.
  \item We pop instruction $\instr{}(1) = \texttt{astore 2}$ from the worklist.
    We have $\wkin{1} = [C], [D, E, \top]$.
    Applying \textsc{Store} we get $\wkout{1} = [], [D, E, C]$.
    The only successor of $\instr{}(1) = \texttt{astore 2}$ is $\instr{}(2) = \texttt{aload 1}$.
    We assign $\wkin{2}$ as:
    \begin{align*}
      \wkin{2} &= \wkin{2} \sqcup \wkout{1} \\
               &= ([], [D,E,D]) \sqcup [], [D, E, C] \\
               &= [] \sqcup [], [D,E,D] \sqcup [D,E,C] \\
               &= [], [D \sqcup D, E \sqcup E, D \sqcup C] \\
               &= [], [D,E,C]
    \end{align*}
    Since $\wkin{2}$ has changed we add $\instr{}(2) = \texttt{aload 1}$ back into the worklist.
  \item We pop instruction $\instr{}(2) = \texttt{aload 1}$ from the worklist.
    We have $\wkin{2} = [], [D,E,C]$.
    Applying \textsc{Load} we get $\wkout{2} = [E], [D,E,C]$.
    The only successor of $\instr{}(2) = \texttt{aload 1}$ is $\instr{}(3) = \texttt{goto 1}$.
    We assign $\wkin{3}$ as:
    \begin{align*}
      \wkin{3} & = \wkin{3} \sqcup \wkout{2} \\
               &= ([E], [D,E,D]) \sqcup ([E], [D,E,C]) \\
               &= [E] \sqcup [E], [D,E,D] \sqcup [D,E,C] \\
               &= [E \sqcup E], [D \sqcup D, E \sqcup E, D \sqcup C] \\
               &= [E], [D,E,C]
    \end{align*}
    Since $\wkin{3}$ has changed we add $\instr{}(3) = \texttt{goto 1}$ back into the worklist.
  \item We pop instruction $\instr{}(3) = \texttt{goto 1}$ from the worklist.
    We have $\wkin{3} = [E], [D,E,C]$.
    Applying \textsc{Goto} we get $\wkout{3} = [E], [D,E,C]$.
    The only successor of $\instr{}(3) = \texttt{goto 1}$ is $\instr{}(1) = \texttt{astore 2}$.
    We assign $\wkin{1}$ as:
    \begin{align*}
      \wkin{1} &= \wkin{1} \sqcup \wkout{3} \\
               &= ([C], [D, E, \top]) \sqcup ([E], [D,E,C]) \\
               &= [C] \sqcup [E], [D, E, \top] \sqcup [D,E,C] \\
               &= [C \sqcup E], [D \sqcup D, E \sqcup E, \top \sqcup C] \\
               &= [C], [D,E,\top]
    \end{align*}
    $\wkin{1}$ has \textit{not} changed so we do not add it back to the worklist.
  \item The worklist is empty, so the algorithm is done.
  \end{enumerate}
\end{example}

Since Java 6 there is a typechecking algorithm instead.
Type information may be included in each bytecode instruction.
However it \textit{requires} that the start of each
\textit{basic block}\footnote{Instructions are partitioned into different blocks such that only the last instruction of a block may jump to the start of another block.}
has type information.
This typechecking approach avoids the worklist algorithm and the interface problem, since the computation of joins is no longer necessary.
The typechecking algorithm is given in \ref{alg:checking}.

\begin{algorithm}
\caption{JVM Type Checking}\label{alg:checking}
\begin{algorithmic}
  \ForAll{basic blocks of a method body}
    \State $in \gets types(start)$ \Comment{Type info from block start.}
    \ForAll{$i$ | $\instr{}(i)$ is an instruction in the basic block}
      \State $in \gets apply\_rule(intstr{}(i), in)$ \Comment{Apply rule to get $in$ for successors}
      \ForAll{$q$ succeeding $i$}
        \If{$types(q)$ declared}
          \State check $\subtype{in}{types(q)}$ \Comment{Requires the same length}
        \EndIf
      \EndFor
    \EndFor
  \EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Parametric Polymorphism}

Classes and methods may be parameterized with types (\textit{yay!}). In OOP this is called \textit{generic types}. It is possible to specify upper bounds on these type parameters. Upper bounds via subtyping on type parameters is the lame OOP way of accomplishing ad-hoc polymorphism, like typeclasses in Haskell or traits in Rust. If $\subtype{S}{T}$, how should we relate $\generic{G}{S}$ and $\generic{G}{T}$?

\begin{example}[Covariant Generics]
Suppose:
\begin{mathpar}
\inferrule
{\subtype{S}{T}}
{\subtype{\generic{G}{S}}{\generic{G}{T}}}
\end{mathpar}
In Java we could define a class for lists:
\begin{lstlisting}[escapechar=|, language=Java, escapechar=|]
class List<A> {
    void add (A a) { ... }
    A head () { ... }
}
\end{lstlisting}
Suppose we had client code:
\begin{lstlisting}
List<String> ls = new List<String>();
List<Object> lo = ls;
ls.add("Hello there");
Object o = lo.head();
lo.add(new Object);
\end{lstlisting}
Everything works fine until we add a \texttt{Object} to the \texttt{String} list. recall the principle that \covar{} types work for reads but not for writes! Thus in general \covar{} generics are not sound. If we allowed \covar{} generics than we would need a \textit{\runtimecheck{}} for \textit{writes}.
\end{example}

\begin{example}[Contravariant Generics]
Suppose:
\begin{mathpar}
\inferrule
{\subtype{S}{T}}
{\subtype{\generic{G}{T}}{\generic{G}{S}}}
\end{mathpar}
Consider the previous \texttt{List} class.
Now we could write client code:
\begin{lstlisting}[escapechar=|, language=Java]
List<Object> lo = new List<Object>();
List<String> ls = lo;
lo.add(new Object);
ls.add("General Kenobi");
String s = ls.head();
\end{lstlisting}
This time everything works until we try to get the head from the list as a \texttt{String}, because it is an  \texttt{Object}. The recall the principle that \contra{} types work for writes but not for reads! Thus in general \contra{} generics are unsound. If we allowed \contra{} generics than we would need a \textit{\runtimecheck{}} for \textit{reads}.
\end{example}

Java has chosen to only allow \textit{\invar{}} generics.
By contrast Scala only has \invar{} generics by default, allowing one to specify if a type parameter is \covar{} or \contra{}. Scala allows \contra{} type parameters when they only occur in a positive position, are only read from.
Scala allows \contra{} type parameters when they only occur in a negative positive, i.e. are only written to.

\begin{example}[Scala \covar{} parameter]
Consider an immutable cell in Scala:
\begin{lstlisting}[escapechar=|, language=Scala]
class ImmutableCell[+A] (val : A) {
    def get() : A { val }
}
\end{lstlisting}
Here \texttt{A} is only used as a return type, i.e. a positive position.

Question: what about constructor?
\end{example}

\begin{example}[Scala \contra{} parameter]
Consider a comparison interface:
\begin{lstlisting}[escapechar=|, language=Scala]
interface Comparison[-A] {
    int compare(A);
}
\end{lstlisting}
Here \texttt{A} is only used as a method parameter to be written to, i.e. a negative positive.
\end{example}

\begin{example}[Logger: constraints on type bounds.]
  Java rejects the following definition of \texttt{Logger}.
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
class Logger<T> {
    public void log(T t) {
        System.out.println(t.loggerString());
    }
}

public class Program {
    public static void main(String args[]) {
        Logger<Integer> logger = new Logger<Integer>();
        logger.log(42); |\label{line:log42}|
    }
}
\end{lstlisting}
  This is because Java does not know whether $T$ has a \texttt{loggerString()} method.
  If the typechecker accepted the above then a runtime error would be thrown when we try to execute line~\ref{line:log42}.
  We need to \textit{constrain} $T$ in \texttt{Logger}'s definition so that we know it has a \texttt{loggerString()} method.
  This is called \textit{bounded polymorphism}.
  We can adjust the above example with the following.
\begin{lstlisting}[escapechar=|, language=Java]
interface Loggable {
    String loggerString();
}

class LoggableInt implements Loggable {
    private int z;
    
    public LoggableInt(int z) {
        this.z = z;
    }
    
    public String loggerString() {
        return Integer.toString(this.z);
    }
}

class Logger<T extends Loggable> {
    public void log(T t) {
        System.out.println(t.loggerString());
    }
}

public class Program {
    public static void main(String args[]) {
        Logger<LoggableInt> logger = new Logger<LoggableInt>();
        logger.log(new LoggableInt(42));
    }
}
\end{lstlisting}
  Now the example typechecks and prints ``42'' as desired.
  Since $T$ only occurs in \textit{negative} positions in \texttt{Logger},
  allowing \contra{} subtyping for instances of \texttt{Logger} would be safe, even though Java does not allow it.
  The below would be ok at \runtime{} if $\subtype{B}{A}$.
\begin{lstlisting}[escapechar=|, language=Java]
void foo(Logger<A> logA) {
    Logger<B> logB = logA;
    logB.log(new B());
}
\end{lstlisting}
  If Java allowed \contra{} generics then \runtimecheck{}s would be needed to ensure that reads of values expected to $T$ (from fields or method calls) are actually subtypes of the expected type.
\end{example}

\begin{example}[Recursively-defined constraints]
  Sometimes when declaring a generic class it needs itself as one of the bounds for a type variable.
  This is particularly common for binary methods.
  Consider the following attempt at an abstract class \texttt{Comparable}.
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
public abstract class Comparable<T> {
    public abstract int compareTo(T other);
    public boolean greaterThan(T other) {
        return other.compareTo(this) < 0; |\label{line:othernotcomparable}|
    }
}
\end{lstlisting}
  Java's typechecker rejects the above because on line~\ref{line:othernotcomparable} $T$ may not have a \texttt{compareTo} method.
  Thus we need to constraint $T$ by \texttt{Comparable}, the class being defined.
  A first attempt is to do the following:
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
abstract class Comparable<T extends Comparable<T>> {
    public abstract int compareTo(T other);
    public boolean greaterThan(T other) {
        return other.compareTo(this) < 0; |\label{line:thisnotT}|
    }
}
\end{lstlisting}
  Java's typechecker still rejects this because on line~\ref{line:thisnotT} we pass \texttt{this} of type \texttt{Comparable<T>} into \texttt{compareTo} which expects a $T$.
  Thus also need to modify \texttt{compareTo}'s signature.
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
abstract class Comparable<T extends Comparable<T>> {
    public abstract int compareTo(Comparable<T> other);
    public boolean greaterThan(T other) {
        return other.compareTo(this) < 0;
    }
}
\end{lstlisting}
  We can avoid changing the signatures by doing:
\begin{lstlisting}[escapechar=|, language=Java,numbers=left]
abstract class Comparable<T> {
    public abstract int compareTo(T other);
    public boolean greaterThan(T other) {
        return 0 < this.compareTo(other);
    }
}
\end{lstlisting}
  This notion of recursive type constraints is \textit{F-bounded-polymorphism}.
\end{example}

When we are stuck with $\invar{}$ generics how do we write code that works with different instantiations of a type parameter?

In OOP (especially Java) this is an issue when what you want is ad-hoc polymorphic functionality for a supertype that works on subtypes, but since you don't have ad-hoc polymorphism you need to create another interface and class(es) that have their own subtype relations. Also you cannot pass functions as arguments in these languages in general so ... here's a convoluted example to motivate a kind of problem one may encounter.

\begin{example}[Additional type parameters]
Here we are going to try to demonstrate that Java forces one to twist themselves into a pretzel if they just want to use standard type parameters.
Suppose there's some \texttt{Comparator} interface and generic \texttt{TreeSet} class that represents a set implemented in a tree data structure.
In order to search for elements it needs to compare elements in binary nodes of the tree.
Thus it needs some way to have a \texttt{compare} function for its elements.
Because we are in Java we cannot pass functions as arguments.
\begin{lstlisting}[escapechar=|, language=Java]
interface Comparator<T> {
    int compare(T x, T y);
}

class TreeSet<E extends Comparator<E>> {
    ...
    TreeSet () {}
    void add (E elem) { ... }
    boolean member (E elem) { ... }
    void remove (E elem) { ... }
}
\end{lstlisting}
Suppose that we would like to create a \texttt{TreeSet<Student>} where \texttt{Student}s are a \texttt{Person}, and \texttt{Person} has a general comparison operation for people.
\begin{lstlisting}[escapechar=|, language=Java]
class Person implements Comparator<Person> {
    ...
    int compare (Person x, Person y) { ... }
}

class Student extends Person {
    ...
}
\end{lstlisting}
Where we would like to have client code:
\begin{lstlisting}[escapechar=|, language=Java]
TreeSet<Student> ts = new TreeSet<Student>();
\end{lstlisting}
Well too bad.
Java gets angry because \texttt{Student} is ``not within the bounds of the type variable (of \texttt{TreeSet})."
That is, we don't know $\subtype{Student}{\generic{Comparator}{Student}}$.
If we try to have \texttt{Student} directly implement the \texttt{Comparator} interface Java still isn't satisfied:
\begin{lstlisting}[escapechar=|, language=Java]
class Student extends Person implements Comparator<Student> {
    int compare(Student x, Student y) { ... }
}
\end{lstlisting}
Java complains that ``\texttt{Comparator} cannot be inherited with different arguments: \texttt{Student} and \texttt{Person}."
If \texttt{Person} does not implement \texttt{Comparator} then Java is satisfied, but we would like it to.
If we would like to have our cake and eat it too we need to modify our \texttt{TreeSet} class as follows:
\begin{lstlisting}[escapechar=|, language=Java]
class TreeSet<E extends F, F extends Comparator<F>> {
    ...
    TreeSet () {}
    void add (E elem) { ... }
    boolean member (E elem) { ... }
    void remove (E elem) { ... }
}
\end{lstlisting}
And then out client code would need to look like:
\begin{lstlisting}[escapechar=|, language=Java]
TreeSet<Person, Student> ts = new TreeSet<Person, Student>();
\end{lstlisting}
Here we needed to make explicit in \texttt{TreeSet}'s type parameters that the element type does not necessarily need to have its own \texttt{Comparator}, but that it has a supertype that implements \texttt{Comparator}.
As shown this is very tedious.
\end{example}

How can we avoid addition type parameters and constraints?

\subsubsection{Wildcards}

\begin{definition}[Wildcards]
Java has so called \textit{wildcard}s that represent \textit{existential types}.
\begin{equation}
\generic{G}{?} \triangleq \exists A, \generic{G}{A}
\end{equation}
In Java there is no way to explicitly instantiate these existential types.
Java's type system does this automatically.
The type argument to the instance of an existential type is abstract to clients.
\end{definition}

\begin{example}[Wildcard identity]
Java accepts the following identity function:
\begin{lstlisting}[escapechar=|, language=Java]
static List<?> id(List<?> l) {
    return l;
}
\end{lstlisting}
In the body of \texttt{id} the Java compiler is able to show $\exists E, \generic{List}{E}$, where \texttt{l} is a \textit{proof} of $\exists E, \generic{List}{E}$.
However it does not know that the parameter type and return type are the same.
\begin{lstlisting}[escapechar=|, language=Java]
List<String> l = id(new ArrayList < String > );
\end{lstlisting}
The above fails because java only knows that the result of \texttt{id(new ArrayList<List>)} is $\exists E, \generic{List}{E}$.
Java does not remember that the $E$ in question is a \texttt{String}.
The best we can do is:
\begin{lstlisting}[escapechar=|, language=Java]
List<?> l = id(new ArrayList < String > );
\end{lstlisting}
Java does not even allow:
\begin{lstlisting}[escapechar=|, language=Java]
List<Object> l = id(new ArrayList < String > );
\end{lstlisting}
Since Java generics are \textit{\invar{}} in general $\exists E, \generic{G}{E} \nless: \generic{G}{Object}$.
\end{example}

\begin{example}[Reading from and writing to wildcards]
Java rejects the following:
\begin{lstlisting}[escapechar=|, language=Java]
static void merge (Collection<?> x, Collection<?> y) {
    x.addAll(y);
}
\end{lstlisting}
We have the following types:
\begin{align*}
    \texttt{x} &: \exists A, \generic{Collection}{A} \\
    \texttt{y} &: \exists B, \generic{Collection}{B} \\
    \texttt{addAll} &: \forall C, \generic{Collection}{C} \times (\exists D, \generic{Collection}{D} \wedge \subtype{D}{C}) \rightarrow ()
\end{align*}
When \texttt{x} is the receiver of \texttt{addAll}, its universal type $C$ is instantiated with some unknown parameter type.
Java is implicitly unpacking \texttt{x}'s type as some unknown $A$.
$$ \generic{\texttt{addAdll}}{A} : \generic{Collection}{A} \times (\exists D, \generic{Collection}{D} \wedge \subtype{D}{A}) \rightarrow ()$$
When \texttt{y} is passed as an argument to \texttt{x.addAll} \texttt{y}'s type is implicitly unpacked with some unknown type parameter $B$.
Java will not be able to satisfy the type bounds of
$$ \generic{\texttt{addAdll}}{A} : \generic{Collection}{A} \times (generic{Collection}{B} \wedge \subtype{B}{A}) \rightarrow ()$$
Since there's no relationship between $A$ and $B$.
Even if we try:
\begin{lstlisting}[escapechar=|, language=Java]
static void merge (Collection<?> x, Collection<?> y) {
for (Object elem : y) {
        x.add(elem);
    }
}
\end{lstlisting}
Java will still be unconvinced.
We have:
\begin{align*}
\texttt{add} &: \forall C, \generic{Collection}{C} \times C \rightarrow () \\
\generic{\texttt{add}}{A} &: \generic{Collection}{A} \times A \rightarrow ()
\end{align*}
Which is even more strict.
Of course $\subtype{A}{Object}$ and $\subtype{B}{Object}$.
However in order to pass \texttt{elem} into \texttt{x.add}, we need that \texttt{\subtype{Object}{A}}.
\end{example}

We would like to be able to constrain wildcards in some way.

\begin{definition}[Bounding wildcards]
Java offers the following:
\begin{align*}
\generic{G}{? ~ \texttt{extends} ~ T} &\triangleq \exists A, \generic{G}{A} \wedge \subtype{A}{T} \\
\generic{G}{? ~ \texttt{super} ~ T} &\triangleq \exists A, \generic{G}{A} \wedge \subtype{T}{A}
\end{align*}
\end{definition}

\begin{example}[Reading from and writing to wildcards revisited]
We may now constrain the existential type parameters in our \texttt{merge} example:
\begin{lstlisting}[escapechar=|, language=Java]
static <E> void merge (Collection<? super E> x, Collection<? extends E> y) {
    x.addAll(y);
    for (A elem : y) {
        x.add(elem);
    }
}
\end{lstlisting}
Everything works now because we have the following:
\begin{align*}
\texttt{x} &: \exists A, \generic{Collection}{A} \wedge \subtype{E}{A} \\
\texttt{y} &: \exists B, \generic{Collection}{B} \wedge \subtype{B}{E} \\
\texttt{add} &: \forall C, \generic{Collection}{C} \times C \rightarrow () \\
\texttt{addAll} &: \forall C, \generic{Collection}{C} \times (\exists D, \generic{Collection}{D} \wedge \subtype{D}{C}) \rightarrow () \\
\end{align*}
When \texttt{x}'s type gets implicitly unpacked we get some type $A$ and the knowledge that $\subtype{E}{A}$.
Similarly when \texttt{y}'s type is unpacked we get some type $B$ and the knowledge that $\subtype{B}{E}$.
When \texttt{x} is the \receiver{} of \texttt{add} and \texttt{addAll} we get:
\begin{align*}
\generic{\texttt{add}}{A} &: \generic{Collection}{A} \times A \rightarrow () \\
\generic{\texttt{addAll}}{A} &: \generic{Collection}{A} \times (\exists D, \generic{Collection}{D} \wedge \subtype{D}{A}) \rightarrow () \\
\end{align*}
Thus when we pass \texttt{elem} into \texttt{x.add} we need to show that $\subtype{B}{A}$.
This is true by transitivity of subtyping.
The same evidence is used when we pass \texttt{y} into \texttt{x.addAll}.
\end{example}

In java, given some generic class $G$, we can use wildcards to make certain instances of $G$ \covar{} or \contra{}.
This is called \textit{use-site variance}.

\begin{example}[Use-site variance]
Suppose we have some cell class:
\begin{lstlisting}[escapechar=|, language=Java]
class Cell<E> {
    private E elem;
    Cell (E elem) { this.elem = elem; }
    E get () { return this.elem; }
    void set (E elem) { this.elem = elem; }
}
\end{lstlisting}
Say we have that $\texttt{Student extends Person}$.
We can create a \covar{} \texttt{Cell} that only allows us to perform reads:
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
Cell<? extends Person> readOnly = new Cell<Student>(new Student());
Object o  = readOnly.get();  // good
Person p  = readOnly.get();  // good
Student s = readOnly.get();  // bad
readOnly.set(new Object());  // bad
readOnly.set(new Person());  // bad
readOnly.set(new Student()); // bad
\end{lstlisting}
Both of the final \texttt{set} calls fail, as Java is unable to correctly constrain the type parameters.
We have the type information:
\begin{align*}
\texttt{readOnly} &: \exists E, \generic{Cell}{E} \wedge \subtype{E}{Person} \\
\texttt{readOnly.get} &: () \rightarrow E \wedge \subtype{E}{Person} \\
\texttt{readOnly.set} &: E \wedge \subtype{E}{Person} \rightarrow ()
\end{align*}
Where for \texttt{readOnly.get} and \texttt{readOnly.set} $E$ is some unpacked type whose only constraint is that $\subtype{E}{Person}$.
Let's take this line by line.
\begin{enumerate}
\item Declare a \covar{}-use-site \texttt{Cell} with an upper bound \texttt{Person}.
\item Typechecks because the result $E$ of \texttt{readOnly.get} is bounded above by \texttt{Person}, so it is acceptable to assign it to an \texttt{Object}.
\item  Typechecks because the result $E$ of \texttt{readOnly.get} is bounded above by \texttt{Person}, so it is acceptable to assign it to a \texttt{Person}.
\item Reading as a \texttt{Student} fails because we need to somehow show that $\subtype{E}{Student}$, but all we have is that $\subtype{E}{Person}$. In principle $E$ could be a \texttt{Person}, which does not work as a \texttt{Student} in general.
\item Setting the cell to \texttt{Object} fails because we would need to show that $\subtype{Object}{E}$ and $\subtype{Object}{Person}$, which does not hold.
\item Attempting to set the cell to a \texttt{Person} fails because we do not know that $\subtype{Person}{E}$.
\item Setting the cell to a \texttt{Student} fails because of the same principle.
\end{enumerate}
Intuitively writing to \texttt{readOnly} fails because we have information about the lower bound of $E$.

We may also create a \contra{} cell that only allows us to perform writes. Suppose that there is also some class \texttt{MasterStudent extends Student}.
\begin{lstlisting}[escapechar=|, language=Java, numbers=left]
Cell<? super Student> writeonly = new Cell<Person>(new Person());
writeonly.set(new MasterStudent()); // good
writeonly.set(new Student());       // good
writeonly.set(new Person());        // bad
writeonly.set(new Object());        // bad
MasterStudent m = writeonly.get();  // bad
Student s       = writeonly.get();  // bad
Person p        = writeonly.get();  // bad
Object o        = writeonly.get();  // good
\end{lstlisting}

We have the type information:
\begin{align*}
\texttt{readOnly} &: \exists E, \generic{Cell}{E} \wedge \subtype{Person}{E} \\
\texttt{readOnly.get} &: () \rightarrow E \wedge \subtype{Person}{E} \\
\texttt{readOnly.set} &: E \wedge \subtype{Person}{E} \rightarrow ()
\end{align*}
Where for \texttt{readOnly.get} and \texttt{readOnly.set} $E$ is some unpacked type whose only constraint is that \\ $\subtype{Person}{E}$.
Let's take this line by line.

\begin{enumerate}
\item Declares a \contra{}-use-site \texttt{Cell} with a lower bound \texttt{Student}.
\item Typechecks because we have that $\subtype{MasterStudent}{E}$ from $\subtype{MasterStudent}{Student}$ \\ and $\subtype{Student}{E}$.
\item Typechecks because we have that $\subtype{Student}{E}$.
\item Fails because $\subtype{Person}{E}$ does not hold.
\item Fails because $\subtype{Object}{E}$ does not hold.
\item Fails because $\subtype{E}{MasterStudent}$ does not hold in general.
\item Fails because $\subtype{E}{Student}$ does not hold in general.
\item Fails because $\subtype{E}{Person}$ does not hold in general.
\item Typechecks because $\subtype{E}{Objects}$ \textit{always} holds.
\end{enumerate}
In principle it is possible to downcast to a more specific type.
\end{example}

\begin{example}[TreeSet revisited]
We may now only have a single type parameter for \texttt{TreeSet} via wildcards.
\begin{lstlisting}[escapechar=|, language=Java]
class TreeSet<E extends Comparator<?>> {
    ...
    TreeSet () {}
    void add (E elem) { ... }
    boolean member (E elem) { ... }
    void remove (E elem) { ... }
}
\end{lstlisting}
We may now define client code:
\begin{lstlisting}[escapechar=|, language=Java]
TreeSet<Student> ts = new TreeSet<Student>();
\end{lstlisting}
\end{example}

In general wildcards allow more flexibility than vanilla type parameters.
\begin{itemize}
\item Java does not allow lower bounds \texttt{super} for normal type parameters.
\item Instantiation of a wildcard $\generic{G}{?}$ may change over time: it may be reassigned an instance with a different type argument. However when reassigning a normal generic instance of $\generic{G}{T}$ it must always have a type argument of exactly $T$.
\end{itemize}

For some generic type $G$, we may define the set of instance types given some type argument.
TODO: define this better or remove.
\begin{align}
\llbracket \generic{G}{T} \rrbracket &= \{ \generic{H}{T} \mid \forall H, \subtype{H}{G} \} \\
\llbracket \generic{G}{?} \rrbracket &= \{ \generic{H}{T} \mid \forall H, T, \subtype{H}{G} \} \\
\llbracket \generic{G}{\subtype{?}{T}} \rrbracket &= \{ \generic{H}{S} \mid \forall H, S, \subtype{H}{G} \wedge \subtype{S}{T} \} \\
\llbracket \generic{G}{\subtype{S}{?}} \rrbracket &= \{ \generic{H}{T} \mid \forall H, T, \subtype{H}{G} \wedge \subtype{S}{T} \}
\end{align}

\begin{definition}[Subtyping generics]
Given generic types $H$ and $G$, we say that:
$$\subtype{\generic{H}{\mathcal{I}_1}}{\generic{G}{\mathcal{I}_2}} \equiv \llbracket \generic{H}{\mathcal{I}_1} \rrbracket \subseteq \llbracket \generic{G}{\mathcal{I}_2} \rrbracket $$
where $\mathcal{I}$ is either a type parameter or a wildcard bound.
\end{definition}

\begin{figure}
  \begin{mathpar}
    \inferrule
    { \subtype{\generic{H}{\mathcal{I}}}{\generic{G}{\mathcal{I}}} \\
      \subtype{\generic{G}{\mathcal{I}}}{\generic{F}{\mathcal{I}}}}
    {\subtype{\generic{H}{\mathcal{I}}}{\generic{F}{\mathcal{I}}}} \\
    
    % \inferrule
    % {\subtype{S}{T}}
    % {\subtype{\generic{G}{\subtype{?}{S}}}{\generic{G}{T}}}

    \inferrule
    {\subtype{S}{T}}
    {\subtype{\generic{G}{T}}{\generic{G}{\subtype{S}{?}}}}

    \inferrule
    {\subtype{S}{T}}
    {\subtype{\generic{G}{\subtype{?}{S}}}{\generic{G}{\subtype{?}{T}}}}

    \inferrule
    {\subtype{S}{T}}
    {\subtype{\generic{G}{\subtype{T}{?}}}{\generic{G}{\subtype{S}{?}}}}

    % \inferrule
    % {\subtype{S}{T}}
    % {\subtype{\generic{G}{\subtype{?}{S}}}{\generic{G}{\subtype{T}{?}}}}
  \end{mathpar}
  \caption{Generic and wildcard subtyping rules for Java}
  \label{fig:genericsubtype}
\end{figure}

We may write the subtyping rules for generics as in \ref{fig:genericsubtype}.
% TODO: Some are not allowed need to resolve which are sound.

\begin{remark}\label{remark:javaisreallystupid}
\href{https://arxiv.org/pdf/1605.05274.pdf}{Subtyping in Java is undecidable do to wildcards.}
\end{remark}

\begin{example}[Java example rules]
  Here is a concrete Java program that attempts to use certain inference rules.
  It is interesting to see what Java allows and disallows.
\begin{lstlisting}[escapechar=|, language=Java]
import java.util.*;

class Animal {
    
    Animal () {}
}

class Cat extends Animal {
    Cat () {}
    
    void meow () {
        System.out.println("meow");
    }
    
}

class Dog extends Animal {
    Dog () {}
    
    void bark () {
        System.out.println("bark");
    }
    
}

public class MyClass {
    public static void main(String args[]) {
        ArrayList<Animal> lAnimal = new ArrayList<Animal>();
        ArrayList<Cat>    lCat    = new ArrayList<Cat>();
        
        // Java forbids covariant generics
        // lAnimal = lCat;
        // lAnimal.add(new Dog());
        
        // Java forbirds contravariant generics
        // lCat = lAnimal;
        
        
        // Java forbids
        //            S <: T
        // ----------------------
        // G < ? <: S > <: G < T >
        
        ArrayList<Animal>        animalList = new ArrayList<Animal>();
        ArrayList<? extends Cat> catList    = new ArrayList<Cat>();
        
        // Java forbids this?
        // animalList = catList;
        
        // Java allows
        //       S <: T
        // -----------------------
        // G < T > <: G < S <: ? >
        
        ArrayList<? super Cat> catlist    = new ArrayList<Object>();
        ArrayList<Animal>      animallist = new ArrayList<Animal>();
        
        catlist = animallist;
        
        // Java allows
        //            S <: T
        // -------------------------
        // G < ? <: S > <: G < ? <: T >
        
        ArrayList<? extends Animal> ldog = new ArrayList<Dog>(Arrays.asList(new Dog()));
        ArrayList<? extends Cat>    lcat = new ArrayList<Cat>(Arrays.asList(new Cat()));
        ldog = lcat;
        
        // Java forbids writes to covariantly declared object
        // ldog.add(new Dog());
        
        
        // Java allows
        //            S <: T
        // ----------------------
        // G < T <: ? > <: G < S <: ? >
        ArrayList<? super Animal> lsub = new ArrayList<Animal>();
        ArrayList<? super Cat>    ltop = new ArrayList<Object>();
        ltop = lsub;
        
        // Put a Cat in a list with lowerbound as Animal
        ltop.add(new Cat());
        Object element = lsub.get(0);
        System.out.println(element instanceof Cat);
        ((Cat) element).meow();
        
        // Java forbids
        //            S <: T
        // ----------------------
        // G < ? <: S > <: G < T <: ? >
        ArrayList<? super Animal> lTop = new ArrayList<Object>();
        ArrayList<? extends Cat>  lSub = new ArrayList<Cat>(Arrays.asList(new Cat()));
        
        // Java forbids
        // lTop = lSub;
        
        Cat cat1 = lSub.get(0);
        
        // Put a Cat in a list with a lower bound as Animal
        lTop.add(cat1);

        Cat cat = (Cat) lTop.get(0);
        cat.meow();
    }
}
\end{lstlisting}
  It was not possible to obtain assurance as to which inference rules are allowed by Java and those that are not so hopefully this example will illuminate any issues.
\end{example}

\begin{example}[Function composition]
  One can define a ``general'' signature for the composition of two functions as:
\begin{lstlisting}[escapechar=|, language=Java]
import java.util.function.Function;

public class MyClass {
    static <X,Y,Z> Function<X,Z> compose
    (Function<? super X, ? extends Y> f, Function<? super Y, ? extends Z> g){
        return (X x) -> {
            return g.apply(f.apply(x));
        };
    }
    
    public static void main(String args[]) {
        Function<Integer, Integer> f = (Integer i) -> { return i; };
        Function<Number,  Number>  g = (Number n)  -> { return n; };
        System.out.println(compose(f, g).apply(1));
    }
}
\end{lstlisting}
\end{example}

\begin{example}[Concatenating Lists]
  Given a List interface in Java:
\begin{lstlisting}[escapechar=|, language=Java]
interface List<T> {
    public int length();
    public T read(int z);
    public void write(T t);
    default public void writeAll(List<? extends T> ts) {
        for (int z = 0; z < ts.length(); z++) {
            this.write(ts.read(0));
        }
    }
}
\end{lstlisting}
  We can write a \texttt{Concat} class that concatenates two lists with a separator in between.
  Here we have four different implementations of a ``concat'' operation each with varying permissiveness in the types of their arguments.
\begin{lstlisting}[escapechar=|, language=Java]
class Concat<A> {
    public void concat(A sep, List<A> from, List<A> to) {
        to.write(sep);
        to.writeAll(from);
    }
    
    public void concatA1(A sep, List<? extends A> from, List<? super A> to) {
        to.write(sep);
        to.writeAll(from);
    }
    
    public <B extends A> void
    concatA2(B sep, List<B> from, List<A> to) {
        to.write(sep);
        to.writeAll(from);
    }
    
    public <B extends A, C extends B> void
    concatA3(B sep, List<C> from, List<B> to) {
        to.write(sep);
        to.writeAll(from);
    }
}
\end{lstlisting}
  \texttt{concat} is easily the most restrictive. The argument for \texttt{sep} may have any subtype of $A$.
  However arguments for \texttt{from} and \texttt{to} must have \textit{exactly} the type $\generic{List}{A}$.
  This is because generics in Java are \textit{\invar{}}.

  \texttt{concatA1} allows for \texttt{from} to have \textit{use-site covariance} and \texttt{to} to have \textit{use-site contravariance}.
  This is because we would like to \textit{read} from \texttt{from} and \textit{write to} \texttt{to}.
  However \texttt{concatA1} is still limited in that the type of any argument for \texttt{to} must be a supertype of $\generic{List}{A}$.
  It does not allow one to pass in an argument for \texttt{to} that has a strict subtype of $\generic{List}{A}$.


  \texttt{concatA2} allows the type for \texttt{from} to be a subtype of $A$.
  However the type of \texttt{to} still must be exactly $\generic{List}{A}$.

  \texttt{concatA3} allows for the type of \texttt{to} to be a subtype of $\generic{List}{A}$.
  Furthermore the type of \texttt{from} may be any subtype of that.
  However the argument of \texttt{to} may not have a strict supertype of $\generic{List}{A}$.

  Thus \texttt{concatA1}, \texttt{concatA2}, and \texttt{concatA3} are all more permissive than \texttt{concat}.
  \texttt{concatA3} is definitely more permissive than \texttt{concatA2}.
  Consider:
\begin{lstlisting}[escapechar=|, language=Java]
// Z <: Y
static void A2vsA3(Concat<Y> yc, Z z, List<Z> zs) {
    // ok
    yc.concatA3(z, zs, zs);

    // BAD
    yc.concatA2(z, zs, zs);
}
\end{lstlisting}
  \texttt{concatA1} and \texttt{concatA3} are incomparable.
  Consider:
\begin{lstlisting}[escapechar=|, language=Java]
// Z <: Y <: X
static void A1vsA3(Concat<Y> yc, Y y, Z z, List<X> xs, List<Z> zs) {
    // ok
    yc.concatA1(y, zs, xs);

    // BAD
    yc.concatA3(y, zs, xs);

    // ok    
    yc.concatA3(z, zs, zs);

    // BAD
    yc.concatA1(z, zs, zs);
}
\end{lstlisting}

  For the sake of argument we could consider what if Java had Scala-like variance annotations.
  We could accomplish something equally as permissive as \texttt{concatA1} if we add some more interfaces.
\begin{lstlisting}[escapechar=|, language=Java]
interface ReadList<+T> {
    public int length();
    public T read(int z);
}

interface WriteList<-T> {
    public void write(T t);
    default public void writeAll(ReadList<? extends T> ts) {
        for (int z = 0; z < ts.length(); z++) {
            this.write(ts.read(0));
        }
    }
}

interface List<T> extends ReadList<T>, WriteList<T> {}

class Concat<A> {
    public void concatB(A sep, ReadList<A> from, WriteList<A> to) {
        to.write(sep);
        to.writeAll(from);
    }
}
\end{lstlisting}
  \texttt{concatA1} and \texttt{concatB} are both equally permissive because they each have the same variance restrictions for their arguments.
  \texttt{concatA1} employs use-site variance whereas \texttt{concatB} relies upon the declared variance annotations.
\end{example}

\subsubsection{Type Erasure}

For backwards compatibility, Sun did not want to change the JVM after generics were introduced. So generic type information is erased by the compiler. $\generic{G}{T}$ becomes just $G$ in java bytecode. Occasionally the compiler needs to insert casts to the class used for the type argument for instances of generic types. Because of this, Java disallows the following:
\begin{itemize}
\item Performing \texttt{instanceOf} on a generic instance type $\generic{G}{T}$.
\item \texttt{.class} of a generic instance type.
\item arrays of generic types $\generic{G}{T}[~]$.
\end{itemize}

C\# allows the above.

\begin{example}[Erasure and overloading]
Java disallows the following because there is a name clash between each \texttt{foo} as a result of type erasure.
\begin{lstlisting}[escapechar=|, language=Java]
class Erasure<S, T> {
    void foo (S p) {}
    void foo (T p) {}
}
\end{lstlisting}
However C\# does allow this in general.
If one chooses to instantiate \texttt{Erasure} with the same types any call to foo will be ambiguous and cause a typechecking error.
\begin{lstlisting}[escapechar=|, language={[Sharp]C}]
Erasure<Object, Object> erasure = new Erasure<Object, Object>();
erasure.foo(new Object()); // ambiguous!
\end{lstlisting}
In Java one can resolve the issue by giving the type parameters different upper bounds.
\end{example}

In Java static fields are shared by all instantiations of a generic class, but not in C\#.

\begin{example}[Lower bounds in Scala]
  Java only allows type variables to have upper bounds.
  However Scala allows lower bounds on type variables.
  Scala's type system does not even bother to check if the lower bound is respected!
  Even if it did it would have to deal with erasure at the bytecode level,
  and the bytecode verifier could not check if lower bounds are respected.
  Scala accepts the following nonsense:
\begin{lstlisting}[escapechar=|, language=Scala]
// X must be a supertype of String.
class Foo[X >: String](val str : X)
// Scala doesn't care LOL
val a = new Foo(1)
print(a.str)
\end{lstlisting}
\end{example}

\subsubsection{C++ Templates}

In C++ one provides type parameters to classes and methods via \textit{templates}. As you will see, intuitively templates are glorified macros.

Every time a template is instantiated the C++ generates an instantiated version of the code for the class or method for the given type arguments. This causes \textit{code bloat}. Furthermore C++ templates are not typechecked. Only the parts of instance classes that get used after the class is instantiated get typechecked. In principle one could make all kinds of assumptions about the type parameter in a template class (about what methods and fields it has) and C++ will not complain unless its instantiation doesn't provide suitable type arguments.

\begin{example}[Simulating mixins in C++]
  In C++ it is possible to emulate the functionality of Scala's mixins via templates.
  This is done by having a template class inherit from its own template parameter.
\begin{lstlisting}[escapechar=|, language=C++]
template <typename T> class Mixin : public T { ... }
\end{lstlisting}
  This technique may be used to write ``mixins'' for a \texttt{Cell} class.
\begin{lstlisting}[escapechar=|, language=C++]
class Cell {
    private: int z;
    
    public:
        Cell(int z) {
            this->z = z;
        }
        
        virtual int read() {
            return this->z;
        }
        
        virtual void write(int z) {
            this->z = z;
        }
};

template<typename C> class Doubling : public C {
    public:
        Doubling(int z) : C(z) {}
        
        virtual void write(int z) {
            this->C::write(2 * z);
        }
};

template<typename C> class Counting : public C {
    private:
        int counter;
    public:
        Counting(int z) : C(z) {
            this->counter = 0;
        }
        
        virtual int read() {
            counter++;
            return this->C::read();
        }
        
        virtual int num_read() {
            return this->counter;
        }
};
\end{lstlisting}
  C++ does not place any restrictions on the type parameters.
  C++ allows us to declare the above template classes with calls such as \texttt{this->C::read()} even though it has no idea whether $C$ will have such a method.
  By instantiating \texttt{Doubling} or \texttt{Counting} with \texttt{Cell} we can obtain mixin-behavior.
\begin{lstlisting}[escapechar=|, language=C++]
int main() {
    Cell* cell = new Cell(2);
    cell->write(5);
    cout << cell->read() << endl;
    
    Doubling<Cell>* dc = new Doubling<Cell>(2);
    dc->write(5);
    cout << dc->read() << endl;
    
    Counting<Cell>* cc = new Counting<Cell>(2);
    cout << cc->num_read() << endl;
    cout << cc->read() << endl;
    cout << cc->num_read() << endl;
    cout << cc->read() << endl;
    cout << cc->num_read() << endl;
    
    Doubling<Counting<Cell>>* dcc = new Doubling<Counting<Cell>>(2);
    cout << dcc->num_read() << endl;
    cout << dcc->read() << endl;
    cout << dcc->num_read() << endl;
    dcc->write(5);
    cout << dcc->read() << endl;
    cout << dcc->num_read() << endl;
    
    Counting<Doubling<Cell>>* cdc = new Counting<Doubling<Cell>>(2);
    cout << cdc->num_read() << endl;
    cout << cdc->read() << endl;
    cout << cdc->num_read() << endl;
    cdc->write(5);
    cout << cdc->read() << endl;
    cout << cdc->num_read() << endl;
    
    Doubling<Doubling<Cell>>* ddc = new Doubling<Doubling<Cell>>(2);
    ddc->write(5);
    cout << ddc->read() << endl;

    return 0;
}
\end{lstlisting}
  Note that \texttt{Doubling} may be ``mixed-in'' more than once!
  In order to get similar behavior in Scala we needed to copy paste a trait and change the name.
  However the lack of type safety may come back to haunt us.
  If we declare some empty class and try to instantiate \texttt{Doubling} the typechecker will reject it.
\begin{lstlisting}[escapechar=|, language=C++]
class Empty {
    public:
        Empty(int z) {}
};

int main() {
    Doubling<Empty>* de = new Doubling<Empty>(2); // C++ says NO.
    return 0;
}
\end{lstlisting}
  However if we adjust \texttt{Empty} to just have a \texttt{write} method, C++ will be ok.
\begin{lstlisting}[escapechar=|, language=C++]
class Empty {
    public:
        Empty(int z) {}
        
        virtual void write(int z) {}
    
};

int main() {
    Doubling<Empty>* de = new Doubling<Empty>(2); // C++ says yes.
    cout << de->read() << endl;                   // C++ says NO.
    return 0;
}
\end{lstlisting}
  Only once we attempt to use a method \texttt{Doubling} doesn't have nor inherit will C++ complain.
\end{example}

C++ later added \textit{concepts}.
Concepts provide a way to specify constraints about a template's type parameter. These constraints are checked upon instantiation.
To read more about concepts look \href{https://en.cppreference.com/w/cpp/language/constraints}{here}.

\section{Information Hiding and Encapsulation}

\epigraph{\itshape The problem with object-oriented languages is theyve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.}{Joe Armstrong}

\subsection{Information Hiding}

\begin{definition}[Information Hiding]
A technique to \textit{reduce} dependencies between modules.
A module only provides clients with the fields and methods such that no invariants can be broken by clients.
This is a \textit{\static{}} concept.
\end{definition}

Ideally class interfaces are thin and hide implementation details.
To understand a single class hopefully one just has to understand the interfaces of any dependencies without looking at their implementations.

To use a class a client should only need to know:
\begin{itemize}
\item The class name.
\item The type parameters and their bounds.
\item The signatures and pre and postconditions of exposed methods.
\item The types, invariants, and constraints of exposed fields.
\item The above for any superclass or superinterface.
\end{itemize}

\begin{example}[Subclass interface]
We for some class $S$ we can consider the interface it has to its superclass $T$.
This includes any \texttt{protected} fields and methods of the superclass.
\end{example}

\begin{example}[Friend (package) interface]
Classes defined in the same package have access to each others \texttt{default} and \texttt{protected} fields and methods.
They may be mutually defined.
\end{example}

Java offers the following access modifiers:
\begin{itemize}
\item \texttt{private}: Only the implementing class has access to these methods and fields. They can not even be \override{}n by subclasses. The most restrictive.
\item \texttt{default}: Only classes defined in the same package has access to these fields and methods. In general they cannot be \override{}n by subclasses, unless the subclass is defined in the same package. Available in the friend interface.
\item \texttt{protected}: These fields and methods are available to classes in the same package and any potential subclasses. Thus they may be \override{}n.  Available in the subclass and friend interface.
\item \texttt{public}: Everyone and their mother has access to these fields and methods. Of course may be \override{}n.
\end{itemize}

\begin{remark}
  The default visibility of methods in Java interfaces is \texttt{public}.
\end{remark}

\begin{remark}
  Methods in abstract classes may not be \texttt{private}.
\end{remark}

Question: how do access modifiers interact with overloading?

Recall \ref{fragile}. In principle any non-\texttt{private} field or method, anything that can be \override{}n may cause problems. Thus when changing a base class, any \textit{observable} behavior, i.e. \textbf{not} \texttt{private} must be preserved.

\begin{definition}[JLS1 Java method selection]
\label{jls1}
When some \receiver{} $o$ invokes a method $m$, \static{}ally/at \compiletime{}:
\begin{enumerate}
\item Find the static declaration of $m$.
\item Determine if $m$ is accessible at the call site.
\item Determine if $m$ is virtual (may be \override{}n) or non-virtual.
\end{enumerate}
Then at \runtime{}
\begin{enumerate}
\item Compute the \receiver{}'s value.
\item Based on the \dynamic{} type of the \receiver{} locate the method $m$ to invoke.
\end{enumerate}
\end{definition}

\begin{definition}[The Access rule]
The access modifier of an overriding method must be at least as open as that of the \override{}n method.
\end{definition}

\begin{definition}[Rules for overriding]
If $\subtype{S}{T}$, $S.m$ \override{}s $T.m$ only if $T.m$ is accessible in $S.m$.
\end{definition}

\begin{example}[Default access methods]
Consider the class \texttt{Super} defined in package \texttt{A}.
\begin{lstlisting}[escapechar=|, language=Java]
package A;
class Super {
    void foo() {
        System.out.println("A");
    }
}
\end{lstlisting}
And the class \texttt{Sub} in package \texttt{B}.
\begin{lstlisting}[escapechar=|, language=Java]
package B;
class Sub extends A.Super {
    public void foo() {
        System.out.println("B");
    }
}
\end{lstlisting}
Suppose we have the following client code that invokes \texttt{foo} in package \texttt{A}.
\begin{lstlisting}[escapechar=|, language = Java]
Super soup = new Sub();
soup.foo();
\end{lstlisting}
Since \texttt{Super.foo()} is not accessible in \texttt{Sub.foo()}, we would expect ``A" to be printed.
This is because \texttt{Super.foo} is \texttt{default}, thus is not available in \texttt{Sub}, and thus cannot be \override{}n by \texttt{Sub.foo}.
However we would be wrong under the rules in \ref{jls1}.
Under these rules \texttt{Sub.foo} will be selected and ``B" will be printed.
Let's step through the rules.
First, at \compiletime{}:
\begin{enumerate}
\item We find the \static{} declaration of \texttt{foo} in \texttt{Super}.
\item We find that \texttt{Super.foo} is accessible at the call site.
\item The invocation is virtual.
\end{enumerate}
Then at \runtime{}:
\begin{enumerate}
\item We find the \dynamic{} type of the \receiver{} \texttt{soup} is \texttt{Sub}.
\item We locate \texttt{Sub.foo} since it is \texttt{public} and in the class \texttt{Sub} of the \receiver{} \texttt{soup}.
\end{enumerate}
\end{example}

\begin{definition}\label{jls2}[JLS2 Java method selection]
Java fixed their broken \ref{jls1} by ensuring that the \dynamic{}ally selected method is able to \override{} the \static{}ally determined method.
When some \receiver{} $o$ invokes a method $m$, \static{}ally/at \compiletime{}:
\begin{enumerate}
\item Find the static declaration of $m$.
\item Determine if $m$ is accessible at the call site.
\item Determine if $m$ is virtual (may be \override{}n) or non-virtual.
\end{enumerate}
Then at \runtime{}
\begin{enumerate}
\item Compute the \receiver{}'s value.
\item Based on the \dynamic{} type of the \receiver{} locate the method $m$ to invoke \textbf{that \override{}s the \static{}ally determined method!}
\end{enumerate}
This is a refinement of \ref{twostep} that more precisely considers access modifiers.
\end{definition}

\begin{example}[Don't always use protection]
Let's consider the previous example, but now the modifiers are \texttt{protected}.
\begin{lstlisting}[escapechar=|, language=Java]
package A;
class Super {
    protected void foo() {
        System.out.println("A");
    }
}
\end{lstlisting}
And the class \texttt{Sub} in package \texttt{B}.
\begin{lstlisting}[escapechar=|, language=Java]
package B;
class Sub extends A.Super {
    protected void foo() {
        System.out.println("B");
    }
}
\end{lstlisting}
Suppose we have the following client code that invokes \texttt{foo} in package \texttt{A}.
\begin{lstlisting}[escapechar=|, language = Java]
package A;
class Client {
    void client() {
        Super soup = new Sub();
        soup.foo();
    }
}
\end{lstlisting}
Again we would expect \texttt{Super.foo} to be invoked, printing ``A", since \texttt{Sub.foo} is \texttt{protected}, and this unavailable to \texttt{Client} as \texttt{Client} is not a subclass of \texttt{Sub} nor is it in the same package.
And again, even under the refined \ref{jls2} we would be wrong.
Let's go through the steps.
At \compiletime{}:
\begin{enumerate}
\item We determine that the \static{} declaration is \texttt{Super.foo}.
\item Since \texttt{Super.foo} is \texttt{protected} and \texttt{Client} is in the same package as \texttt{Super}.
\item \texttt{Super.foo} may be overriden.
\end{enumerate}
Then at \runtime{}:
\begin{enumerate}
\item The \dynamic{} value of \texttt{soup} is \texttt{Sub}.
\item Indeed \texttt{Sub.foo} \override{}s \texttt{Super.foo}, thus \texttt{Sub.foo} is called.
\end{enumerate}
Thus \texttt{Client} was able to call a method that was not even available to it!.
\end{example}

\subsection{Encapsulation}

Ideally, any module behaves the same way, according to its specification, no matter what the calling context it.
The client relies upon the \textbf{consistency of internal representations} of the invoked module.
Furthermore the module should prevent clients from being able to violate its invariants.
For instance, non-\texttt{private} fields are a way to set yourself up for failure, so stay outta trouble kids.

\begin{definition}[Encapsulation]
A technique to separate the memory state available to different \textit{capsules}, so the memory states available to each capsule are disjoint.
The boundaries delimiting memory are achieved via clear interfaces to these capsules so these capsules may guarantee invariants about their internal states.
In this course encapsulation relates to the state of the program at \runtime{}, thus is a \textit{\dynamic{}} concept.
\end{definition}

Often the terms information hiding and encapsulation are used interchangeably, but here they are distinct.

What is a capsule? It can be:
\begin{itemize}
\item An individual object.
\item A structure composed of many objects.
\item A class (with all of its objects).
\item A package (with all of its classes and objects).
\end{itemize}
To provide encapsulation for a capsule we requires a precisely defined boundary and an interface for that boundary.
The internal representation of a capsule is encapsulated if it can only be manipulated using its interface.
To achieve internal consistency (invariants) of objects we should:
\begin{enumerate}
\item Apply information hiding.
\item Make consistency criteria explicit, via the use of contracts, i.e. with invariants, history constraints, pre- and postconditions.
\item Check that anything exposed by the interface, including those of possible subclasses, preserve consistency and prevent malicious clients from breaking consistency.
\end{enumerate}

In practice this means that invariants should only refer to \texttt{private} fields, since anything else can be set by a client.

All this begs the question: what is an object structure?

\section{Object Structures and Aliasing}

\epigraph{\itshape Object-oriented programming had boldly promised ``to model the world." Well, the world is a scary place where bad things happen for no apparent reason, and in this narrow sense I concede that OO does model the world.}{Dave Fancher}

Single objects are the atomic building blocks of OOP. From these we can build more complex objects or \textit{object structures} when their classes have fields that are other objects.

\begin{definition}[Object structure]
A set of objects connected via references.
\end{definition}

\subsection{Aliasing}

\begin{definition}[Aliasing]
We say that an object $o$ is \textit{aliased} by the aliases $x$ and $y$ if they both hold references to $o$.
That is
$$ x \mapsto o \wedge y \mapsto o \wedge x \neq y $$
An alias may be
\begin{itemize}
\item Local variables of methods, including \texttt{this}.
\item Class fields (including static).
\item Left expressions in general.
\end{itemize}
\end{definition}

\begin{definition}[Capturing]
A form of unintended aliasing where a reference gets stored in a data structure.
Often this occurs in constructors.
\end{definition}

Aliases may be used to get around an object's boundary/interface.

\begin{definition}[Leaking]
Occurs when a data structure passes out or exposes a reference to some ostensibly internal object.
This usually happens by mistake.
Leaking can be exploited to bypass an object's boundary/interface.
\end{definition}

\subsection{Problems of Aliasing}

\epigraph{\itshape The big lie of object-oriented programming is that objects provide encapsulation.}{John Hogg.}

\begin{remark}\label{remark:captures}
If an interface has a method that accepts some object or object structure as an argument, and it captures that argument, its interface may be bypassed if the caller decides to mutate what was passed in.
Just making fields private that represent the internal state of the callee does nothing.
\end{remark}

\begin{remark}\label{remark:leaks}
If an interface has a method that returns an object, array, or reference part of its internal data structure this is leaking, and any client may modify this object and thus the internal state.
\end{remark}

Here's a list of some other specific issues with aliasing:
\begin{itemize}
\item When performing explicit memory management one needs to be sure that when one is freeing a pointer that there are no other aliases. This is the so-called \href{https://en.wikipedia.org/wiki/Dangling_pointer}{dangling pointer problem}.
\item Compilers should not inline objects that are aliased.
\end{itemize}

\subsection{Unique References}

For some data structures we would like to be sure there is no aliasing.
Some languages/libraries provide some support for this with \textit{unique pointers}.

\subsubsection{C++ Unique Pointers}

C++ offers a library for unique pointers.
Direct leaking is prevented by the omission of the copy constructor.
Direct capturing is prevent by omission of the assignment operator.

To pass unique pointers around in C++ one needs to explicitly \textit{move} them.
Moving them prevents aliasing by rendering the old pointer unusable.
Accessing the old pointer leads to undefined behavior, such as nontermination.

Because unique pointers are in general not aliased, when they are deleted C++ deallocates the underlying objects as well.
Because there are (in theory) no aliases one does not need to worry out the dangling pointer problem.

\begin{example}[Direct leaking and capturing]
  Consider the following code for an \texttt{Address} and \texttt{Person} class.
\begin{lstlisting}[escapechar=|, language=C++]
class Address {
    public:
        std::string city;

        Address (std::string city) {
            this->city = city;
        }
    
        std::string getCity() {
            return this->city;
        }
}

class Person {
    std::unique_ptr<Address> addr;

    std::unique_ptr<Address> getAddr() { return addr; }

    void setAddr(std::unique_ptr<Address> a) { addr = a; } 
}
\end{lstlisting}

  C++ forbids both \texttt{getAddr} and \texttt{setAddr}.
  C++ rejects \texttt{getAddr} because \texttt{unique\_ptr} deletes the copy constructor, so a pointer cannot be copied out of the class.
  This is good behavior because it prevents a client from aliasing \texttt{addr}, thus no leaking.
  It rejects \texttt{setAddr} because \texttt{unique\_ptr} deletes the assignment operator, preventing the class from having an alias to some pointer the client passed in, thus preventing capturing.
  To get C++ to accept \texttt{Person} we need to use the \texttt{move} operator.

\begin{lstlisting}[escapechar=|, language=C++]
class Person {
    std::unique_ptr<Address> addr;

    std::unique_ptr<Address> getAddr() { return std::move(addr); }

    void setAddr(std::unique_ptr<Address> a) { addr = std::move(a); } 
}
\end{lstlisting}
  In \texttt{getAddr} the pointer in \texttt{addr} is moved out of the class and given to the client.
  Attempting to read from \texttt{Person}'s \texttt{addr} will result in undefined behavior, probably nontermination.
  In \texttt{setAddr} the pointer the client passes will be moved into the \texttt{addr} field, rendering it unusable to the client.
\end{example}

\begin{example}[Ownership transfer]
  When a unique pointer is passed into a function it needs to be moved.
  This means that the client will no longer be able to use it after the call.
  Imagine that there is some compare function on unique pointers of addresses.
\begin{lstlisting}[escapechar=|, language=C++]
int compare(std::unique_ptr<Address> x, std::unique_ptr<Address> y) { ... }
\end{lstlisting}
  Say some client code would like to compare two addresses and do something with them afterwards.
\begin{lstlisting}[escapechar=|, language=C++]
auto x = std::make_unique<Address>("Hagen");
auto y = std::make_unique<Address>("Zurich");
int  c = compare(std::move(x), std::move(y));
auto small_address = c < 0 ? std::move(x) : std::move(y); // C++ mad
\end{lstlisting}
  We would've liked to use \texttt{compare} to figure out the smaller address, but since both \texttt{x} and \texttt{y} were moved into \texttt{compare} the client can no longer access them.
  We could imagine some alternative \texttt{compare} that returns \texttt{x} and \texttt{y} in addition to the \texttt{int}.
\begin{lstlisting}[escapechar=|, language=C++]
std::tuple<int, std::unique_ptr<Address>, std::unique_ptr<Address>>
compare(std::unique_ptr<Address> x, std::unique_ptr<Address> y) { ... }
\end{lstlisting}
  And then use this in the client:
\begin{lstlisting}[escapechar=|, language=C++]
auto x = std::make_unique<Address>("Los Angeles");
auto y = std::make_unique<Address>("Reno");
auto t = compare(std::move(x), std::move(y));
int  c = std::get<0>(t);
x = std::move(get<1>(t));
y = std::move(get<2>(t));
auto small_address = c < 0 ? std::move(x) : std::move(y);
\end{lstlisting}
  C++ accepts this.
  However \texttt{x} and \texttt{y} are moved when we assign \texttt{small\_address}.
  We've merely kicked the problem down the road.
  One could imagine programming in this style but C++ offers another solution.
  Compare could take a pointer to the unique pointer.
  \begin{lstlisting}[escapechar=|, language=C++]
int compare(std::unique_ptr<Address> *x, std::unique_ptr<Address> *y) { ... }
\end{lstlisting}
  Now the client will pass \texttt{x} and \texttt{y} as references into \textt{compare}.
\begin{lstlisting}[escapechar=|, language=C++]
auto x = std::make_unique<Address>("Tokyo");
auto y = std::make_unique<Address>("Cairo");
int  c = compare(&x, &y);
auto small_address = c < 0 ? std::move(x) : std::move(y); // C++ mad
\end{lstlisting}
\end{example}

C++ allows one to create an alias to the data in a unique pointer with a \texttt{get} method.
Obviously this causes problems.

\begin{example}[Dangling unique pointer]
  One can create a dangling pointer using \texttt{get}.
  Imagine there is some method that returns \texttt{get} on a newly created unique address.
\begin{lstlisting}[escapechar=|, language=C++]
Address* make_addr() {
    auto addr = std::make_unique<Address>("Zurich");
    return addr.get();
}
\end{lstlisting}
  And we have a client that tries to call \texttt{getCity} on the result.
\begin{lstlisting}[escapechar=|, language=C++]
std::cout << make_addr()->getCity() << std::endl;
\end{lstlisting}
  Since C++ deletes the data \texttt{addr} points to in \texttt{make\_addr}, calling \texttt{getCity} on the result is undefined behavior.
\end{example}

\begin{example}[Aliasing unique pointers]
  Other than \texttt{get}, one can alias a unique pointer by constructing one with previously existing data.
\begin{lstlisting}[escapechar=|, language=C++]
Address peter_address = new Address("Zurich");
std::unique_ptr<Address> alias(peter_address);
alias->city = "Hagen";
std::cout << peter_address->getCity() << std::endl;
\end{lstlisting}
  We have sent someone to Hagen, which is the worst thing that could happen.
\end{example}

Furthermore, unique pointers in C++ are shallow.
One may easily alias any inner objects or pointers.
To get deep ownership one needs to make all fields unique pointers recursively.

\subsubsection{Rust Ownership}

Rust's type system enforces ownership.
Moves occur implicitly because all assignments are moves.
When one tries to read from a moved value, instead of undefined behavior at \runtime{}, the typechecker rejects the program.
Ownership in Rust is deep.
In Rust the \texttt{Box} type allows one to have deeply owning pointers to memory: a better version of \texttt{unique\_ptr}.

One can transfer values back and force in Rust like in C++, but it is more idiomatic pass by reference.
This is called \textit{borrowing}.
Borrowing creates a temporary alias.
These aliases come with more restrictions.
Read-only references \texttt{\& T} may be shared and have many aliases but cannot be written to.
Mutable references \texttt{\&mut T} may be written to but there may only be one.
Rust's borrow checker analyzes the program syntax and determines the availability of references, or \textit{lifetimes}.
A reference's lifetime is the span of program syntax from when it is born into this world and when it is last used.
Leaking is possible in Rust if a function returns a mutable reference.
However capturing is safe because the capturing data structure owns the captured value.

\begin{remark}\label{remark:rustcoolmem}
  Rust can safely deallocate memory of variables at the end of their scope because of the uniqueness of ownership.
\end{remark}

\begin{remark}\label{remark:rusttree}
  In safe Rust it is not possible to construct cyclic data structures.
\end{remark}

\begin{example}[Moving and Borrowing Rust]
  Here's an example of what ownership does and doesn't allow you to do in Rust.
\begin{lstlisting}[escapechar=|, language=Rust]
struct Data {
  z : i32,
}

impl Data {
  fn new(z : i32) -> Self {
    Data { z }
  }
  
  fn read(&self) -> i32 {
      self.z
  }
  
  fn write(&mut self, z : i32) {
      self.z = z;
  }
  
  fn absorb(self) {}
}

fn main() {
    let d1 = Data::new(0);
  
    println!("{}", d1.read());
    // error[E0596]: cannot borrow `d1` as mutable, as it is not declared as mutable
    // d1.write(2);
  
    let mut d2 = &d1;
    println!("{}", d2.read());
    // error[E0596]: cannot borrow `*d2` as mutable, as it is behind a `&` reference
    // d2.write(2);
    d2 = &Data::new(55);
    // error[E0716]: temporary value dropped while borrowed
    // d2.read();
    // d2.write(25);
    
    // error[E0596]: cannot borrow `d1` as mutable, as it is not declared as mutable
    // let mut d3 = &mut d1;
  
    d1.absorb();
    // error[E0382]: borrow of moved value: `d1`
    // println!("{}", d1.read());
    
    let mut d4 = Data::new(0);
    d4.write(42);
    
    let mut d5 = &mut d4;
    d5.write(32);
    d4.write(20);
    // error[E0499]: cannot borrow `d4` as mutable more than once at a time
    // d5.write(66);
}
\end{lstlisting}
  You can test these examples in \href{https://cognitive-engineering-lab.github.io/aquascope/}{aquascope} to see how the ownership and borrowing rules are enforced.
\end{example}

\subsection{Read-only References}

In stateful programming aliases require much less memory overhead than deep-copying data structures.
So despite their many drawbacks we would like to use aliases, but with much better safety guarantees.
Intuitively we can avoid many of the problems with aliases if we require that they are \textit{read-only}.
We would like to have the following properties for read-only references.
\begin{itemize}
\item Distinguish between clients that may mutate data via a reference verses those who may not. The data itself isn't read-only, the references to it are.
\item Effectively prevent clients from modifying some state.
\item We would like read-only access to extend to fields of data, that is we would like \textit{transitivity}.
\end{itemize}

Rust's read-only references satisfy these properties.

C++ supports \texttt{const} pointers.
On the surface they are read-only.
However inner fields may be updated, and they may be cast to non-constant pointers.

C++ also supports \texttt{const} methods that may not modify their receiver object.
Question: Can const methods update fields within const fields?

TODO: example of rust borrow checking, when a mutable reference may be created after an immutable reference is no longer used.

\section{Initialization}

\epigraph{\itshape I call it my billion-dollar mistake. It was the invention of the null reference in 1965.}{Tony Hoare}

\epigraph{\itshape Null is very nice and intuitive to work with. There's no alternative more expressive, safe, nor efficient.}{Nobody}

\subsection{Simple Non-null Types}

\cringe{} seems convenient.
Programmers like to use \cringe{} to
\begin{enumerate}
\item Indicate the absence of a value. For example as a terminal node in a recursively defined type.
\item Initialize fields by default.
\end{enumerate}

In other words:
\begin{enumerate}
\item The language doesn't have algebraic data types or the programmer chose not to use them.
\item It's an object-oriented setting and the programmer was too lazy to write a constructor that initializes the fields.
\end{enumerate}

\cringe{} is cringe.
Algebraic data types give you more expressiveness and safety.
But some \textit{certain} languages (\textit{cough, cough} Java, C, C++, etc.) thought \cringe{} would be simpler to implement and program with.

Unfortunately will not be getting rid of \cringe{} all together.
Instead we will distinguish between \cringe{} types and \textit{non-\cringe{}} types.
$\nonnull{T}$ denotes references to $T$ objects.
$\nulltyp{T}$ denotes references to $T$ objects \textit{or} \cringe{}.
$$ values(\nulltyp{T}) = \{ \cringe{} \} \cup values(\nonnull{T}) $$

\begin{definition}[Type safety invariant]\label{definition:nulltypesafeinv}
  We would like to \static{}ally  guarantee:
  $$\forall e, v, T, e : \nonnull{T} \rightarrow e \downarrow v \rightarrow v \neq \cringe{}$$
  We would like to prevent \cringe{} dereferencing at \compiletime{} (while still having \cringe{} in the language).
  I.e. we would like to prevent the \receiver{} from ever being \cringe{}.
  Because $values(\nonnull{T}) \subset values(\nulltyp{T})$ we may have the following subtyping rules:
  \begin{mathpar}
    \inferrule
    {S ~ \texttt{extends} ~T}
    {\subtype{\nonnull{S}}{\nonnull{T}}}

    \inferrule
    {S ~ \texttt{extends} ~T}
    {\subtype{\nulltyp{S}}{\nulltyp{T}}}

    \inferrule
    { }
    {\subtype{\nonnull{T}}{\nulltyp{T}}}
  \end{mathpar}
  Downcasts from $\nulltyp{T}$ to $\nonnull{T}$ require a \textit{\runtimecheck{}}.
\end{definition}

Because downcasts are inherently unsafe but needed if we every want to do something with a \cringe{} type, we need to first check whether or not an instance of a \cringe{} type is really indeed \cringe{}.
To prevent \compiletime{} errors for potential \cringe{} dereferencing our type system will use a \textit{dataflow analysis}.

\begin{example}[Checking \cringe{}]
  Consider some \texttt{Map} class that represents a key-value map.
\begin{lstlisting}[escapechar=|, language=Java]
class Map {
    private Object! key;
    private Object! val;
    private Map? next;

    public Map (Object! key, Object! val, Map? next) {
        this.key = key;
        this.val = val;
        this.next = next;
    }

   public Object? get (Object! key) {
       if (this.key == key) return this.value;
       return this.next.get(key);
   }
}
\end{lstlisting}
  \texttt{get} is not \cringe{}-safe because \texttt{this.next} could be \cringe{}.
  So we need to first check whether it is \cringe{} before we use it as a \receiver{}.
\begin{lstlisting}[escapechar=|, language=Java]
public Object? get (Object! key) {
    if (this.key == key) return this.value;
    if (this.next == null) return null;
    return this.next.get(key);
}
\end{lstlisting}
  This seems like a reasonable solution, and in a sequential setting it could be.
  However interleavings are possible that allow some other thread to set \texttt{this.next} to \cringe{} before \texttt{this.next.get(key)} is invoked.
  Thus we need to assign to a local variable first.
\begin{lstlisting}[escapechar=|, language=Java]
public Object? get (Object! key) {
    if (this.key == key) return this.value;
    Map? nextUp = this.next;
    if (nextUp == null) return null;
    return nextUp.get(key);
}
\end{lstlisting}
  There is no way for another thread to set \texttt{nextUp} to anything.
  Thus a dataflow analysis is powerful enough to see that when \texttt{nextUp.get(key)} is called we can guarantee that \texttt{nextUp} won't be \cringe{}.
  In general dataflow analyses are only powerful enough to reason about local variables like \texttt{nextUp}, not heap locations such as \texttt{this.next}.
\end{example}

\subsection{Object Initialization}

Constructing new objects poses many challenges when attempting to guarantee \ref{definition:nulltypesafeinv}.
Consider:
\begin{itemize}
\item We need to ensure that non-\cringe{} fields are initialized to a non-\cringe{} value when the constructor has completed.
\item Non-\cringe{} fields may be \cringe{} before construction is finished.
\end{itemize}

Remember that in general it is okay for invariants to be violated in the middle of a function's execution.
This may pose a problem especially in concurrent settings.

\begin{definition}[Definite assignment rule]
  \label{definition:defassrule}
  Every local variable must assigned to prior to its first use, particularly as a \receiver{}.
  For object types this is especially important to prevent \cringe{}-dereferencing.
  This may be checked by a dataflow analysis and during bytecode verification.
\end{definition}

\begin{remark}
  Languages such as Java and C\# do not initialize declared variables, but do let you use them.
\end{remark}

We would like to extend {definition:defassrule} to fields as well, but this is difficult to enforce in constructors.
Especially because subobjects will implicitly or explicitly invoke the superobjects constructor during their constructor.

\begin{example}[Dynamically-bound problems.]
  Consider the didactically named class \texttt{Demo}.
\begin{lstlisting}[escapechar=|, language=Java]
class Demo {
    private Vector! cache;

    Demo () {
        int size = optimalSize();
        this.cache = new Vector(size);
    }

    int optimalSize () { return 16; }
}
\end{lstlisting}
  By this point, the OO guru in you is observing that calling a potentially dynamically-bound method, \texttt{optimalSize}, in the constructor is asking for trouble.
  You may also be asking why not make \texttt{optimalSize} a constant field instead of a method.
  Don't think about.
  Don't ask questions.
  As you would expect a subclass can cause problems.
\begin{lstlisting}
class SubDemo extends Demo {
    private Vector! data;

    SubDemo (Vector! d) {
        // implicit call super()
        this.data = d.clone();
    }

    int optimalSize () { return this.data.size() * 2; }
}
\end{lstlisting}
  Every time we attempt to invoke the constructor for \texttt{SubDemo} bad things will happen: we will get a \cringe{}-exception.
  You may ask, where did we go wrong (other than that we used OOP).
  All \receiver{}s have non-\cringe{} types!
  \begin{enumerate}
  \item When the constructor for \texttt{SubDemo} is invoked it first (implicitly) invokes \texttt{Demo}'s constructor.
  \item \texttt{Demo}'s constructor's call to \texttt{optimalSize} is \overide{}n by \texttt{SubDemo}'s.
  \item In \texttt{SubDemo.optimalSize} we call \texttt{this.data.size()}.
  \item But \texttt{this.data} has not yet been initialized to a non-\cringe{} value!
  \item So we get a \cringe{}-pointer exception!
  \end{enumerate}
\end{example}

\begin{example}[Callback problems]
  Problems may occur if a class's constructor calls a method that call's one of its own dynamically-bound methods.
  Once we again have an appropriately named \texttt{Demo} class.
\begin{lstlisting}
class Demo implements Observer {
    static Subject! subject;

    Demo () {
        // register this as an observer of this.subject
        this.subject.register(this);
    }

    void update () { ... }
}
\end{lstlisting}
  Question: when does \texttt{this.subject} get initialized?

  No dynamically-bound calls occur within \texttt{Demo}'s constructor.
  The \texttt{Subject} class looks like:
\begin{lstlisting}[escapechar=|, language=Java]
class Subject {
    void register (Observer! o) {
        ...
        o.update();
        ...
    }
}
\end{lstlisting}
  However again we may write a subclass that causes problems:
\begin{lstlisting}[escapechar=|, language=Java]
class SubDemo extends Demo {
     private Vector! data;

     SubDemo (Vector! d) {
         // implicit super() call
         this.data = d.clone();
     }

    void update () {
        ...
        something = this.data.size();
        ...
    }
}
\end{lstlisting}
  Once again a call to \texttt{SubDemo}'s constructor will throw a \cringe{}-pointer exception!
  \begin{enumerate}
  \item \texttt{SubDemo}'s constructor begins by implicitly invoking \texttt{Demo}'s constructor.
  \item \texttt{Demo}'s constructor invokes \texttt{this.subject.register(this)}.
  \item In \texttt{Subject.register} \texttt{update} is called, which is \override{}n in \text{SubDemo}.
  \item In \texttt{SubDemo.update} \texttt{this.data.size()} is invoked.
  \item But \texttt{this.data} is has not been initialized to a non-\cringe{} value so it is still \cringe{}!
  \item A \cringe{} value as a \receiver{} throws a \cringe{}-pointer exception!
  \end{enumerate}
\end{example}

\begin{example}[Concurrency woes]
  So maybe the constructor doesn't even indirectly call one of its own \dynamic{}ally bound methods.
  Concurrent execution still has something to say.
\begin{lstlisting}[escapechar=|, language=Java]
class Demo implements Observer {
    static Subject! subject;

    Demo () {
        // register this as an observer of this.subject
        this.subject.register(this);
    }

    void update () { ... }
}

class SubDemo extends Demo {
     private Vector! data;

     SubDemo (Vector! d) {
         // implicit super() call
         this.data = d.clone();
     }

    void update () {
        ...
        something = this.data.size();
        ...
    }
}

class Subject extends Thread {
    List<Observer!>! observers;

    void register (Observer! o) { observers.add(o);  }

    void run () {
        for (Observer! o : this.observers) o.update();
    }
}
\end{lstlisting}
  Here the problem arises from an unlucky interleaving.
  Consider the following execution.
  \begin{enumerate}
  \item \texttt{SubDemo}'s constructor is invoked.
  \item The implicit \texttt{super()} call is invoked.
  \item In \texttt{Demo}'s constructor \texttt{this} is registered as an observer.
  \item In \texttt{Subject.register} out object under construction is added to \texttt{observers}.
  \item Our constructor's execution is preempted by the thread calling \texttt{Subject.run}.
  \item \texttt{update} is called upon our object under constructor, which is \dynamic{}ally bound to that in \texttt{SubDemo}.
  \item In \texttt{Subject.update} \texttt{this.data.size()} is invoked.
  \item But \texttt{this.data} is still \cringe{}, so a \cringe{}-pointer exception is thrown.
  \end{enumerate}
\end{example}

\begin{example}[Concurrent woes continued]
  Okay.
  I give up.
  I will not make \textit{any} method calls during a constructor at all.
  Here's an \textit{innocent} class with a cycle of processes.
\begin{lstlisting}[escapechar=|, language=Java]
class Cycle {
    Cycle! next;
    Process! proc;

    Cycle (Process! p) {
        this.next = this;
        this.proc = p;
    }

    Cycle (Cycle! neighbor, Process! p) {
         this.next = neighbor.next;
         neighbor.next = this;
         this.proc = p;
    }
}
\end{lstlisting}
  Imagine we have some scheduler that goes through a cycle.
\begin{lstlisting}[escapechar=|, language=Java]
class Scheduler extends Thread {
    Cycle! current;

    Scheduler (Cycle! cycle) {
        this.current = cycle;
    }

    void run () {
        while (true) {
            this.current.proc.preempt();
            this.current = this.current.next;
            this.current.proc.resume();
            Thread.sleep(1000);
        }
    }
}
\end{lstlisting}
  Say we have some client code that creates process cycle for a scheduler, runs the scheduler, then decides to add another process to the cycle.
\begin{lstlisting}[escapechar=|, language=Java]
Process! eat   = new Process(...);
Process! poop  = new Process(...);
Process! sleep = new Process(...);

Cycle! eats    = new Cycle(eat);
Cycle! poops   = new Cycle(eats, poop);
Cycle! sleeps  = new Cycle(poops, sleep);

Scheduler dailySchedule = new Scheduler(eats);

// Spawn a new thread, calls dailySchedule.run()
dailySchedule.spawn();

Process! game  = new Process(...);

Cycle! games   = new Cycle(eats, game);
\end{lstlisting}
  Here we create a daily scheduling that includes eating, pooping, and sleeping.
  Later we decide to add gaming to our schedule.
  This will be totally okay, right...?
  Imagine the following execution:
  \begin{enumerate}
  \item The \texttt{eat}, \texttt{poop}, and \texttt{sleep} processes are initialized without issue.
  \item These processes are used to create a daily schedule \texttt{dailySchedule}, that first eats, poops, sleeps, eats, etc.
  \item A new thread is spawned that runs the scheduler.
  \item We decide to add a new process \texttt{game} for gaming to our cycle after eating and before pooping.
  \item In the constructor for \texttt{Cycle} \texttt{eats} is passed for \texttt{neighbor} and \texttt{game} is passed for \texttt{proc}.
  \item \texttt{this.next} is assigned to \texttt{eats.next} which is \texttt{poops}.
  \item \texttt{neighbor.next}, which is \texttt{eats.next}, is assigned to \texttt{this}.
  \item Uh-oh, we've been preempted by the scheduler!
  \item For \texttt{dailySchedule.run}, at the moment of preemption \texttt{this.current} was set to \texttt{eats}.
  \item Now \texttt{eats.next}, which is our object under construction, becomes \texttt{this.current}.
  \item \texttt{this.current.proc.resume()} is invoked.
  \item \texttt{this.current.proc} is the \texttt{proc} field for our object under construction, which has not yet been assigned and is still \cringe{}!
  \item A \cringe{}-pointer exception is thrown!
  \end{enumerate}
\end{example}

Currently our type system for non-\cringe{} types is not powerful enough to \static{}ally guarantee that no \cringe{}-pointer exceptions occur when a class field of a partially-initialized object escapes from its constructor.

It \textit{cannot} ensure that during initialization that uninitialized fields are not used a \receiver{}s when
\begin{itemize}
\item The object under construction calls a dynamically-bound method.
\item The object under construction passes itself or one of its uninitialized fields into another function that calls a dynamically-bound method.
\item The object under construction or one of its uninitialized fields is stored in some data structure that concurrently that is available to another thread.
\end{itemize}

We may be able to solve this problem by prevent constructors from making dynamically bound calls, passing itself or any of its uninitialized fields into another function call, and synchronizing constructors.
However this is much less expressive and \dynamic{}ally has more overhead.
We would like to adopt a more fine-grained approach.
To do this we need to consider the initialization phases for an object.

When a constructor is invoked, we can consider the following stages:
\begin{enumerate}
\item When \texttt{new} is invoked the object now exists any may be used, even though it has not yet been initialized!
\item At some point during the initialization process all of the object's fields become initialized.
\item The constructor call has completed execution.
\end{enumerate}

Before step 1 the object cannot be used because it does not yet exist.
Between steps 1 and 2 we cannot make any assumptions about the \cringe{}ness of the object's fields but the object and its fields may be accessed.
After step 2 we know that all of the object's non-\cringe{} fields are not \cringe{}.

We would like our type system to work based on understanding which stage the object's construction is at.
For our purposes the second step is too fine-grained so we may simply consider that

\begin{enumerate}
\item When \texttt{new} is invoked the object now exists any may be used, even though it has not yet been initialized!
\item The constructor call has completed execution and all of its fields are initialized.
\end{enumerate}

Between steps 1 and 2 the object and its fields occupy some nether state where they may be accessed but we know nothing about their \cringe{}ness.
I.e. for some field $this.f : \nonnull{T}$, $this.f$ may actually be \cringe{} even though its type says otherwise.
Our type system needs to be expressive enough to reason about the fact that \ref{definition:nulltypesafeinv} may be temporally violated within a call to a constructor.
Thus the type $\nonnull{T}$ on its own cannot express this.
Thus we need to introduce types for different stages of object construction.
We call these \textit{construction types}.
\begin{itemize}
\item Free types $\freetyp{T}$ represents values of type $T$ during object constructions, in particular for uninitialized fields.
\item Committed types $\committed{T}$ represents values of type $T$ after an object constructor has completed execution.
\item Unclassified types $\unctyp{T}$ represents values of type $T$ that may be either free or committed.
\end{itemize}

Note that $\committed{\nulltype{T}}$ is allowable, it just expresses fully initialized values of $T$ that may be \cringe{}.
In general we take that $\committed{T}$ is synonymous with $T$.

We may introduce the following subtyping rules.
\begin{mathpar}
  \inferrule
  { }
  {\subtype{\committed{\nonnull{T}}}{\unctyp{\nonnull{T}}}}

  \inferrule
  { }
  {\subtype{\freetyp{\nonnull{T}}}{\unctyp{\nonnull{T}}}}

  \inferrule
  { }
  {\subtype{\committed{\nulltyp{T}}}{\unctyp{\nulltyp{T}}}}

  \inferrule
  { }
  {\subtype{\freetyp{\nulltyp{T}}}{\unctyp{\nulltyp{T}}}}
\end{mathpar}

Note that we must ban casts from unclassified types to free and committed types.
Question: but why? What role do unclassified types have anyway?

Our new type systems needs certain requirements.

\begin{definition}[Local initialization]\label{definition:localinit}
  We say that an object is \textit{locally initialized} if and only if its non-\cringe{} fields are not \cringe{}.
  If the \static{} type of a term is committed then its value at \runtime{} is locally initialized.
  \begin{table}[h]
    \centering
  \begin{tabular}{| c | c | c |}
    \hline
    construction & ! & ? \\
    \hline
    committed & ! & ? \\
    \hline
    free & ? & ? \\
    \hline
    unclassified & ? & ? \\
    \hline
  \end{tabular}
  \caption{Possible \cringe{} reads for each combination of (non-) \cringe{} and construction types.}
  \label{table:constrlocal}
\end{table}
See \ref{table:constrlocal} for the possibilities for \cringe{} reads of a field of some term.
$$\text{locally\_initialized}(o) = \Gamma \vdash o : \committed{\nonnull{T}} \rightarrow \forall f : \nonnull{T} \in fields(A) \rightarrow o.f \neq \cringe{}$$
Local initialization is a \textit{partial} property.
\end{definition}

\begin{definition}[Transitive initialization]\label{definition:transinit}
  We say that an object is \textit{transitively initialized} if all reachable objects from its fields satisfy \ref{definition:localinit}.
  We would like to guarantee that if a term's \static{} type is committed then its value at \runtime{} is transitively initialized.
  \begin{mathpar}
    \inferrule
    { \text{locally\_initialized}(o) \\
      \forall f \in fields(o) \rightarrow \text{transitively\_initialized}(o.f)}
    {\text{transitively\_initialized}(o)}
  \end{mathpar}
  Transitive initialization may be considered to be a property that holds for an \textit{entire} object.
  A committed object is transitively initialized.
\end{definition}

\begin{definition}[Typing field writes]
  \label{definition:fieldwritetype}
  We may type field writes as:
  \begin{mathpar}
    \inferrule
    { \Gamma \vdash e_1 : C_1 ~ \nonnull{A} \\
      \Gamma \vdash e_2 : C_2 ~ S \\
      f : T \in fields(A) \\
      \subtype{S}{T} \\
      C_1 = \texttt{free} \vee C_2 = \texttt{com}
    }
    {\Gamma \vdash e_1.f = e_2 : unit }
  \end{mathpar}
  \begin{table}[h]
    \centering
    \begin{tabular}{| c | c | c | c |}
      \hline
      & $\Gamma \vdash e_2 : \committed{S}$ & $\Gamma \vdash e_2 : \freetyp{S}$ & $\Gamma \vdash e_2 : \unctyp{S}$ \\
      \hline
      $\Gamma \vdash e_1 : \committed{\nonnull{A}}$ & Ok & NO & NO \\
      \hline
      $\Gamma \vdash e_1 : \freetyp{\nonnull{A}}$ & Ok & Ok & Ok \\
      \hline
      $\Gamma \vdash e_1 : \unctyp{\nonnull{A}}$ & Ok & NO & NO \\
      \hline
    \end{tabular}
    \caption{$C_1 = \texttt{free} \vee C_2 = \texttt{com}$}
    \label{table:constrfieldwrite}
  \end{table}
  The condition  $C_1 = \texttt{free} \vee C_2 = \texttt{com}$ is depicted for all combinations of construction types in \ref{table:constrfieldwrite}.
\end{definition}

\begin{definition}[Typing field reads]
  we may type field reads as:
  \begin{mathpar}
    \inferrule
    { \Gamma \vdash e : C ~ \nonnull{A} \\
      f : T \in fields(A) }
    {\Gamma \vdash e.f : \mathcal{F}(C, T)}
  \end{mathpar}
  Where $\mathcal{F}$ is defined as:
  \begin{align*}
    \mathcal{F}(\texttt{com}, \nonnull{T}) &= \committed{\nonnull{T}} \\
    \mathcal{F}(\texttt{com}, \nulltyp{T}) &= \committed{\nulltyp{T}} \\
    \mathcal{F}(\texttt{free}, T \_) &= \unctyp{\nulltyp{T}}  \\
    \mathcal{F}(\texttt{unc}, T \_) &=  \unctyp{\nulltyp{T}}
  \end{align*}
  \begin{table}[h]
    \centering
    \begin{tabular}{| c | c | c |}
      \hline
      & $f : \nonnull{T} \in fields(A)$ & $f : \nulltyp{T} \in fields(A)$ \\
      \hline
      $\Gamma \vdash e : \committed{\nonnull{A}}$ & $\Gamma \vdash e.f : \committed{\nonnull{T}}$ & $\Gamma \vdash e.f : \committed{\nulltyp{T}}$ \\
      \hline
      $\Gamma \vdash e : \freetyp{\nonnull{A}}$ & $\Gamma \vdash e.f : \unctyp{\nulltyp{T}}$ & $\Gamma \vdash e.f : \unctyp{\nulltyp{T}}$ \\
      \hline
      $\Gamma \vdash e : \unctyp{\nonnull{A}}$ & $\Gamma \vdash e.f : \unctyp{\nulltyp{T}}$ & $\Gamma \vdash e.f : \unctyp{\nulltyp{T}}$ \\
      \hline
    \end{tabular}
    \caption{$\mathcal{F}$ as a table.}
    \label{table:constrfieldread}
  \end{table}
  $\mathcal{F}$ may be expressed as \ref{table:constrfieldread}.
  At first glance it may seem like a type $\committed{\nulltyp{T}}$ is a paradox: does such a type violate \ref{definition:transinit}?
  Such a type is actually okay because it is all right for a committed non-\cringe{} type to have a \cringe{} field.
  The idea is that a type being non-\cringe{} is a property of a local variable, and it being committed is a property of the object that a local variable points to.
  When you read from free field it is unclassified (either free or committed).
  Fields of free refs are unclassified.
  When we read a field from a free reference its possibly null, so we need to check.
\end{definition}

\begin{definition}[Typing constructor declarations]
  When we type the body of a constructor, we assume that \texttt{this} has a free, non-\cringe type.
  By the end non-\cringe{} values must be assigned to non-\cringe{} fields.
  That is the constructor must have the explicit syntax \texttt{this.field = <not null>} for each field of a non-\cringe{} type.
  This is called \textit{the definite assignment check}.
  Constructors may either call free or unclassified methods
\end{definition}

\begin{definition}[Typing method calls]
  The \receiver{} of a method call must be non-\cringe{}.
  Construction types for methods are those for \receiver{}, so subtyping with them is \contra{}.
\end{definition}

How do we know when construction is complete?
Naively we would say that construction is complete at the end of a call to a constructor.
However this is not true in general: a subobject could just have finished calling \texttt{super()} but still has more to do.
Knowing if object construction is complete is generally \textit{non-modular}.

We might say that construction is complete when the \texttt{new} expression terminates.
However this is only valid for \textit{surface} calls to \texttt{new}.
In other words, a constructor may call \texttt{new} within its declaration.
This is particularly a problem if such a call to \texttt{new} contains terms that are free, such as \texttt{this}.
In general objects created with \texttt{new} do not satisfy \ref{definition:transinit} when done.
However they should always satisfy \ref{definition:localinit} when done.

\begin{remark}\label{remark:constrstrongupdate}
  At the end of a call to \texttt{new} fields will have a strong update to their types to become committed.
\end{remark}

We must require surface-level \texttt{new} expressions to only take committed arguments.
This is because assigning \texttt{this}'s fields to under-initialized arguments, i.e. not initialized or merely those that satisfy \ref{definition:localinit} is banned because there is no way that they will become committed or satisfy \ref{definition:transinit} by the end of construction.
However we will allow \texttt{new} expressions invoked in constructors to take arguments of any construction type.

Thus we may make the following observations about what type of arguments \texttt{new} expressions may or may not allow.
First concerning surface-level calls to \texttt{new}:
\begin{itemize}
\item The \texttt{this} under construction may only be given committed arguments to assign to fields. I.e, all arguments must satisfy \ref{definition:transinit}.
\item Any committed argument may not have a field assigned to \texttt{this}. This would violate \ref{definition:fieldwritetype} and the argument would no longer satisfy \ref{definition:transinit}.
\item An argument merely satisfying \ref{definition:localinit} is banned because it is not fully committed. Furthermore updating any of its fields to \texttt{this} is also forbidden because it would no longer satisfy \ref{definition:localinit}.
\item An argument that is uninitialized is forbidden because it is not fully committed.
\end{itemize}

Not let us consider nested calls to \texttt{new}.
\begin{itemize}
\item The inner \texttt{this} under construction may not have any of its fields assigned to \textit{external} under-initialized values, as there would be no way to ensure that the final object satisfies \ref{definition:transinit}.
\item The inner \texttt{this} may have some of its fields assigned to the surface-level \texttt{this}, even though both are free.
\item Once the inner \texttt{this} has completed its own construction, it satisfies \ref{definition:localinit}.
\item The outer \texttt{this} may assign one of its fields to the result of the inner \texttt{new}.
\item Once all of the inner \texttt{this}'s fields have been assigned, it satisfies \ref{definition:localinit}.
\item Observe that all of these \texttt{new} objects when done only refer to objects that satisfy \ref{definition:transinit}, or each other, which satisfy \ref{definition:localinit}.
\end{itemize}

Thus at the end of surface-level constructor call the constructed object will satisfy \ref{definition:transinit}.

\begin{definition}[Typing \texttt{new} expressions]
  \begin{mathpar}
    \inferrule
    { \forall i, \Gamma \vdash e_i : C_i ~ S_i \\
      constructor(A) : C'_i ~ T_i \rightarrow \nonnull{A} \\
      \forall i, \subtype{C_i ~ S_i}{C'_i ~ T_i} \\
      ((\forall i, C_i = \texttt{com}) \rightarrow C = \texttt{com}) \vee C = \texttt{free}
    }
    {\Gamma \vdash \texttt{new} ~ A(e_i) : C ~ \nonnull{A}}
  \end{mathpar}
\end{definition}

Now in general methods need to be annotated with \texttt{free} to invoke them during construction.
Such methods may not use \texttt{this} as a \receiver{}.

Free and unclassified arguments to nested new must have come from within the surface constructor.

\begin{example}[Declared vs actual types]
  Formal construction type of parameter doesn't matter as much as static type of argument.
\begin{lstlisting}[escapechar=|, language=Java]
public C {
    public C (unc String c) {...}
}
\end{lstlisting}
We may do the following since committed types are subtypes of unclassified types.
\begin{lstlisting}
String s = "Hello";
C x = new C(s); // ok, will know s is committed
\end{lstlisting}
\end{example}

\begin{definition}[Lazy Initialization]
  Constructing new objects with all of their data and fields may take time, and cause long waits at the start of an application.
  The idea here is to initialize fields \textit{when they are first used}.
  This means that many fields may have \cringe{}-types and thus every method that uses a particular field must check that it is indeed not \cringe{} when it tries to use it.
  If a field is \cringe{} the method is responsible for initializing it.
  This is a design choice, not a language construct.
  Consider we define a class aptly named \texttt{Demo} in typical fashion.
\begin{lstlisting}[escapechar=|, language=Java]
class Demo {
    private Vector! data;

    Demo () {
        this.data = new Vector();
    }

    public Vector! getData() {
        return this.data.clone();
    }
}
\end{lstlisting}
  However if we choose to do lazy initialization our \texttt{Demo} will look more like:
\begin{lstlisting}[escapechar=|, language=Java]
class Demo {
    private Vector? data;

    Demo () {
        // does nothing
    }

    public Vector! getData() {
        Vector? d = this.data;
        if (d = null) {
            d = new Vector();
            this.data = d;
        }
        return d.clone();
    }
}
\end{lstlisting}
\end{definition}

\begin{definition}[Array Initialization]
  It is difficult for a static analyzer to check in a decidable way if all non-\cringe{} members of an array field are properly initialized in a constructor.
  Array initialization is typically accomplished with loops, but static analyzers have difficulties reasoning about loops.
  To ensure that all non-\cringe{} members of an array are properly initialized one could:
  \begin{itemize}
  \item Assign the field directly rather than each member. \\
    \texttt{String![]! arr = \{``Hey'', ``Baby''\}}
  \item Have language support for putting default values into the array (Eiffel).
  \item Use a \runtimecheck{} at the end of the constructor.
\begin{lstlisting}[escapechar=|, language=Java]
free String![]! arr = new String![arrLength];
for (int i; i < arrLength; i++) {
     arr[i] = i % 2 ? "Even" : "Odd";
}
NonNullType.AssertInitialized(arr);
this.arr = arr;
\end{lstlisting}
  \end{itemize}
  Note that the type rule for array assignment forces right hand side to be committed.
\end{definition}

Note that we do not allow overloads from differences in construction types. Checkout spec sharp.


\begin{remark}\label{remark:superatendofsub}
  Some of the pitfalls of initialization may be avoided if the call to the super constructor takes place at end of sub constructor.
\end{remark}

\subsection{Initialization of Global Data}

\epigraph{\itshape Why are we still here? Just to suffer?}{Kazuhira Miller}

\begin{definition}[Design goals for initializing global data]
  We would like our solution to initialize global data to satisfy the following criteria.
  \begin{enumerate}
  \item \textbf{Effectiveness:} We would like to ensure that global data is initialized \textit{before its first access}. For instance we would like ostensibly non-\cringe{} to actually not be \cringe{} when we use it?
  \item \textbf{Clarity:} The semantics of initialization are simple to reason about.
  \item \textbf{Laziness:} Global data is initialized \textit{lazily} to reduce boot-up time.
  \end{enumerate}
  Since we are in an OOP can you guess which of the above will \textit{not} generally hold?
\end{definition}

\begin{definition}[Global variables and init methods]\label{def:globalvarinitmethod}
  Initialization of global variables could be done by \textit{explicit} calls to \texttt{init} methods.
  These \texttt{init} methods must be called in directly or indirectly from \texttt{main}.
  If a global variable in module $A$ depends upon a global variable from module $B$, \texttt{main} needs to somehow initialize $B$'s global variables first.
  Thus it requires (the implementors of) \texttt{main} to know the dependency structure of imported modules.
  How did we do?
  \begin{enumerate}
  \item \textbf{Effectiveness, Strike:} Initialization order needs to be set \textit{manually} by the programmer, and programmers are of course infallible.
  \item \textbf{Clarity, Strike:} Need to know module dependencies requires non-modular reasoning and violates \textit{information hiding}.
  \item \textbf{Laziness, Meh:} Possible but also needs to be coded manually.
  \end{enumerate}
  Two strikes (one strike is enough to be bad here)!
\end{definition}

\begin{example}[C++ Initializers]
  This is more of a variation of \ref{def:globalvarinitmethod} than its own conceptual solution.
  Here initializers are executed not by but \textit{before} \texttt{main}.
  No explicit calls to these initializers by the programmer are needed.
  The order these are executed depends upon \textit{the order they appear in the source code}.
  Thus the order must again be determined by the programmer.
  In C++ the programmer needs to declare modules in right order.
  How did we do this time?
  \begin{enumerate}
  \item \textbf{Effectiveness, Strike:} Initialization order needs to be set \textit{manually} by the programmer, and programmers are of course infallible.
  \item \textbf{Clarity, Strike:} Need to know module dependencies requires non-modular reasoning and violates \textit{information hiding}.
  \item \textbf{Laziness, Strike:} No support for this.
  \end{enumerate}
  Three strikes and this attempt is out!
\end{example}

\begin{definition}[Static fields and initializers (in Java)]\label{def:staticinit}
  \texttt{static} fields store references to global data.
  \texttt{static} initializers are executed by the system \textit{immediately before a class is used at \runtime{}}.
  Thus initialization happens \textit{lazily}.
  The \runtime{} systems manages dependencies between modules.
  However it is possible (in Java) for \texttt{static} initializers and fields in different classes to be \textit{mutually dependent}.
  As you could expect, this could easily lead to \cringe{}-pointer exceptions.
  Because \texttt{static} initializers may have arbitrary side effects reasoning about them is \textit{non-modular}.
  To understand what value a \texttt{static} field will have requires knowing the order initializers are run, which requires executing the program.
  How did we do this time?
  \begin{enumerate}
  \item \textbf{Effectiveness, Strike:} \cringe{}-pointer exceptions are incredibly likely.
  \item \textbf{Clarity, Strike:} Need to know module dependencies requires non-modular reasoning and violates \textit{information hiding}.
    Furthermore one needs to effectively execute a program to understand the order initializers will be executed, what values \texttt{static} fields will have, etc.
  \item \textbf{Laziness, Yes:} Done at the last possible moment.
  \end{enumerate}
  Two strikes! Laziness is just a wet blanket here.
  Basically, in Java \texttt{static} initializers calling \texttt{static} stuff from other class causes problems.
\end{definition}

\begin{example}[Scala Singletons]
  Scala provides language support for singletons\footnote{\href{https://en.wikipedia.org/wiki/Singleton_pattern}{A class with a single instance}}.
  But because these are defined by translation to Java they are glorified examples of \ref{def:staticinit}.
\end{example}

\begin{definition}[Once Methods (Eiffel)]
  \texttt{Once} methods are executed exactly twice.
  Just kidding, they're only executed only once.
  The \texttt{Result} of the first call is cached and used for all subsequent calls.
  Thus for all subsequent calls the arguments are ignored.
  For recursive methods the current value of \texttt{Result} is used.
  How does this do?
  \begin{enumerate}
  \item \textbf{Effectiveness, Strike:} Reading initialized fields is possible.
  \item \textbf{Clarity, Strike:} Need to know when \texttt{Once} methods were first called and with what values, may be cluttered by concurrency.
  \item \textbf{Laziness, Yes:} Done at the last possible moment.
  \end{enumerate}
  Two strikes!
  But what were we expecting from Eiffel?
\end{definition}

Sadly there is no solution (that uses global data) that properly ensures (in particular non-\cringe{}) global data is initialized before it is first used.
This is especially complicated by mutual dependencies between modules.

\section{Reflection}

When calling \texttt{f.get(o)}, $o$ may not have field $f$,
or $f$ may not be accessible, etc.
Thus we need \runtimecheck{}s because Java cannot \static{}ally guarantee that reflection method calls are okay.
\texttt{setAccessible} can be disabled by security manager.
\texttt{setAccessible} doesn't change class, just allows one to get a method of any visibility.
Java cannot change established class code at \runtime{}, but Python can!

\end{document}
